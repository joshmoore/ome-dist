// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Search.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __omero_api__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_api_Search_h__
#define __omero_api__opt_hudson_workspace_OMERO_5_0_release_src_components_blitz_generated_omero_api_Search_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <omero/ServicesF.h>
#include <omero/System.h>
#include <omero/Collections.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace omero
{

namespace api
{

class Search;

}

}

}

namespace omero
{

namespace api
{

class Search;
bool operator==(const Search&, const Search&);
bool operator<(const Search&, const Search&);

}

}

namespace IceInternal
{

::Ice::Object* upCast(::omero::api::Search*);
::IceProxy::Ice::Object* upCast(::IceProxy::omero::api::Search*);

}

namespace omero
{

namespace api
{

typedef ::IceInternal::Handle< ::omero::api::Search> SearchPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::omero::api::Search> SearchPrx;

void __read(::IceInternal::BasicStream*, SearchPrx&);
void __patch__SearchPtr(void*, ::Ice::ObjectPtr&);

}

}

namespace omero
{

namespace api
{

class AMI_Search_activeQueries : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Int) = 0;

    void __response(::Ice::Int __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_activeQueries> AMI_Search_activeQueriesPtr;

class AMD_Search_activeQueries : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_activeQueries> AMD_Search_activeQueriesPtr;

class AMI_Search_setBatchSize : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_setBatchSize> AMI_Search_setBatchSizePtr;

class AMD_Search_setBatchSize : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_setBatchSize> AMD_Search_setBatchSizePtr;

class AMI_Search_getBatchSize : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Int) = 0;

    void __response(::Ice::Int __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_getBatchSize> AMI_Search_getBatchSizePtr;

class AMD_Search_getBatchSize : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_getBatchSize> AMD_Search_getBatchSizePtr;

class AMI_Search_setMergedBatches : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_setMergedBatches> AMI_Search_setMergedBatchesPtr;

class AMD_Search_setMergedBatches : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_setMergedBatches> AMD_Search_setMergedBatchesPtr;

class AMI_Search_isMergedBatches : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_isMergedBatches> AMI_Search_isMergedBatchesPtr;

class AMD_Search_isMergedBatches : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_isMergedBatches> AMD_Search_isMergedBatchesPtr;

class AMI_Search_setCaseSentivice : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_setCaseSentivice> AMI_Search_setCaseSentivicePtr;

class AMD_Search_setCaseSentivice : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_setCaseSentivice> AMD_Search_setCaseSentivicePtr;

class AMI_Search_isCaseSensitive : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_isCaseSensitive> AMI_Search_isCaseSensitivePtr;

class AMD_Search_isCaseSensitive : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_isCaseSensitive> AMD_Search_isCaseSensitivePtr;

class AMI_Search_setUseProjections : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_setUseProjections> AMI_Search_setUseProjectionsPtr;

class AMD_Search_setUseProjections : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_setUseProjections> AMD_Search_setUseProjectionsPtr;

class AMI_Search_isUseProjections : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_isUseProjections> AMI_Search_isUseProjectionsPtr;

class AMD_Search_isUseProjections : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_isUseProjections> AMD_Search_isUseProjectionsPtr;

class AMI_Search_setReturnUnloaded : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_setReturnUnloaded> AMI_Search_setReturnUnloadedPtr;

class AMD_Search_setReturnUnloaded : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_setReturnUnloaded> AMD_Search_setReturnUnloadedPtr;

class AMI_Search_isReturnUnloaded : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_isReturnUnloaded> AMI_Search_isReturnUnloadedPtr;

class AMD_Search_isReturnUnloaded : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_isReturnUnloaded> AMD_Search_isReturnUnloadedPtr;

class AMI_Search_setAllowLeadingWildcard : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_setAllowLeadingWildcard> AMI_Search_setAllowLeadingWildcardPtr;

class AMD_Search_setAllowLeadingWildcard : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_setAllowLeadingWildcard> AMD_Search_setAllowLeadingWildcardPtr;

class AMI_Search_isAllowLeadingWildcard : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_isAllowLeadingWildcard> AMI_Search_isAllowLeadingWildcardPtr;

class AMD_Search_isAllowLeadingWildcard : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_isAllowLeadingWildcard> AMD_Search_isAllowLeadingWildcardPtr;

class AMI_Search_onlyType : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_onlyType> AMI_Search_onlyTypePtr;

class AMD_Search_onlyType : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_onlyType> AMD_Search_onlyTypePtr;

class AMI_Search_onlyTypes : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_onlyTypes> AMI_Search_onlyTypesPtr;

class AMD_Search_onlyTypes : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_onlyTypes> AMD_Search_onlyTypesPtr;

class AMI_Search_allTypes : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_allTypes> AMI_Search_allTypesPtr;

class AMD_Search_allTypes : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_allTypes> AMD_Search_allTypesPtr;

class AMI_Search_onlyIds : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_onlyIds> AMI_Search_onlyIdsPtr;

class AMD_Search_onlyIds : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_onlyIds> AMD_Search_onlyIdsPtr;

class AMI_Search_onlyOwnedBy : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_onlyOwnedBy> AMI_Search_onlyOwnedByPtr;

class AMD_Search_onlyOwnedBy : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_onlyOwnedBy> AMD_Search_onlyOwnedByPtr;

class AMI_Search_notOwnedBy : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_notOwnedBy> AMI_Search_notOwnedByPtr;

class AMD_Search_notOwnedBy : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_notOwnedBy> AMD_Search_notOwnedByPtr;

class AMI_Search_onlyCreatedBetween : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_onlyCreatedBetween> AMI_Search_onlyCreatedBetweenPtr;

class AMD_Search_onlyCreatedBetween : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_onlyCreatedBetween> AMD_Search_onlyCreatedBetweenPtr;

class AMI_Search_onlyModifiedBetween : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_onlyModifiedBetween> AMI_Search_onlyModifiedBetweenPtr;

class AMD_Search_onlyModifiedBetween : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_onlyModifiedBetween> AMD_Search_onlyModifiedBetweenPtr;

class AMI_Search_onlyAnnotatedBetween : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_onlyAnnotatedBetween> AMI_Search_onlyAnnotatedBetweenPtr;

class AMD_Search_onlyAnnotatedBetween : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_onlyAnnotatedBetween> AMD_Search_onlyAnnotatedBetweenPtr;

class AMI_Search_onlyAnnotatedBy : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_onlyAnnotatedBy> AMI_Search_onlyAnnotatedByPtr;

class AMD_Search_onlyAnnotatedBy : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_onlyAnnotatedBy> AMD_Search_onlyAnnotatedByPtr;

class AMI_Search_notAnnotatedBy : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_notAnnotatedBy> AMI_Search_notAnnotatedByPtr;

class AMD_Search_notAnnotatedBy : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_notAnnotatedBy> AMD_Search_notAnnotatedByPtr;

class AMI_Search_onlyAnnotatedWith : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_onlyAnnotatedWith> AMI_Search_onlyAnnotatedWithPtr;

class AMD_Search_onlyAnnotatedWith : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_onlyAnnotatedWith> AMD_Search_onlyAnnotatedWithPtr;

class AMI_Search_addOrderByAsc : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_addOrderByAsc> AMI_Search_addOrderByAscPtr;

class AMD_Search_addOrderByAsc : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_addOrderByAsc> AMD_Search_addOrderByAscPtr;

class AMI_Search_addOrderByDesc : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_addOrderByDesc> AMI_Search_addOrderByDescPtr;

class AMD_Search_addOrderByDesc : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_addOrderByDesc> AMD_Search_addOrderByDescPtr;

class AMI_Search_unordered : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_unordered> AMI_Search_unorderedPtr;

class AMD_Search_unordered : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_unordered> AMD_Search_unorderedPtr;

class AMI_Search_fetchAnnotations : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_fetchAnnotations> AMI_Search_fetchAnnotationsPtr;

class AMD_Search_fetchAnnotations : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_fetchAnnotations> AMD_Search_fetchAnnotationsPtr;

class AMI_Search_fetchAlso : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_fetchAlso> AMI_Search_fetchAlsoPtr;

class AMD_Search_fetchAlso : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_fetchAlso> AMD_Search_fetchAlsoPtr;

class AMI_Search_resetDefaults : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_resetDefaults> AMI_Search_resetDefaultsPtr;

class AMD_Search_resetDefaults : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_resetDefaults> AMD_Search_resetDefaultsPtr;

class AMI_Search_byGroupForTags : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_byGroupForTags> AMI_Search_byGroupForTagsPtr;

class AMD_Search_byGroupForTags : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_byGroupForTags> AMD_Search_byGroupForTagsPtr;

class AMI_Search_byTagForGroups : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_byTagForGroups> AMI_Search_byTagForGroupsPtr;

class AMD_Search_byTagForGroups : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_byTagForGroups> AMD_Search_byTagForGroupsPtr;

class AMI_Search_byFullText : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_byFullText> AMI_Search_byFullTextPtr;

class AMD_Search_byFullText : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_byFullText> AMD_Search_byFullTextPtr;

class AMI_Search_byLuceneQueryBuilder : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_byLuceneQueryBuilder> AMI_Search_byLuceneQueryBuilderPtr;

class AMD_Search_byLuceneQueryBuilder : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_byLuceneQueryBuilder> AMD_Search_byLuceneQueryBuilderPtr;

class AMI_Search_bySimilarTerms : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_bySimilarTerms> AMI_Search_bySimilarTermsPtr;

class AMD_Search_bySimilarTerms : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_bySimilarTerms> AMD_Search_bySimilarTermsPtr;

class AMI_Search_byHqlQuery : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_byHqlQuery> AMI_Search_byHqlQueryPtr;

class AMD_Search_byHqlQuery : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_byHqlQuery> AMD_Search_byHqlQueryPtr;

class AMI_Search_bySomeMustNone : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_bySomeMustNone> AMI_Search_bySomeMustNonePtr;

class AMD_Search_bySomeMustNone : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_bySomeMustNone> AMD_Search_bySomeMustNonePtr;

class AMI_Search_byAnnotatedWith : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_byAnnotatedWith> AMI_Search_byAnnotatedWithPtr;

class AMD_Search_byAnnotatedWith : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_byAnnotatedWith> AMD_Search_byAnnotatedWithPtr;

class AMI_Search_clearQueries : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_clearQueries> AMI_Search_clearQueriesPtr;

class AMD_Search_clearQueries : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_clearQueries> AMD_Search_clearQueriesPtr;

class AMI_Search_and : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_and> AMI_Search_andPtr;

class AMD_Search_and : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_and> AMD_Search_andPtr;

class AMI_Search_or : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_or> AMI_Search_orPtr;

class AMD_Search_or : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_or> AMD_Search_orPtr;

class AMI_Search_not : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_not> AMI_Search_notPtr;

class AMD_Search_not : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_not> AMD_Search_notPtr;

class AMI_Search_hasNext : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(bool) = 0;

    void __response(bool __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_hasNext> AMI_Search_hasNextPtr;

class AMD_Search_hasNext : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(bool) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_hasNext> AMD_Search_hasNextPtr;

class AMI_Search_next : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::model::IObjectPtr&) = 0;

    void __response(const ::omero::model::IObjectPtr& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_next> AMI_Search_nextPtr;

class AMD_Search_next : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::model::IObjectPtr&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_next> AMD_Search_nextPtr;

class AMI_Search_results : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::IObjectList&) = 0;

    void __response(const ::omero::api::IObjectList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_results> AMI_Search_resultsPtr;

class AMD_Search_results : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::api::IObjectList&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_results> AMD_Search_resultsPtr;

class AMI_Search_currentMetadata : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::SearchMetadata&) = 0;

    void __response(const ::omero::api::SearchMetadata& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_currentMetadata> AMI_Search_currentMetadataPtr;

class AMD_Search_currentMetadata : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::api::SearchMetadata&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_currentMetadata> AMD_Search_currentMetadataPtr;

class AMI_Search_currentMetadataList : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(const ::omero::api::SearchMetadataList&) = 0;

    void __response(const ::omero::api::SearchMetadataList& __ret)
    {
        ice_response(__ret);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_currentMetadataList> AMI_Search_currentMetadataListPtr;

class AMD_Search_currentMetadataList : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(const ::omero::api::SearchMetadataList&) = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_currentMetadataList> AMD_Search_currentMetadataListPtr;

class AMI_Search_remove : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response() = 0;

    void __response()
    {
        ice_response();
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::omero::api::AMI_Search_remove> AMI_Search_removePtr;

class AMD_Search_remove : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::omero::api::AMD_Search_remove> AMD_Search_removePtr;

}

}

namespace IceAsync
{

namespace omero
{

namespace api
{

class AMD_Search_activeQueries : public ::omero::api::AMD_Search_activeQueries, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_activeQueries(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_setBatchSize : public ::omero::api::AMD_Search_setBatchSize, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_setBatchSize(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_getBatchSize : public ::omero::api::AMD_Search_getBatchSize, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_getBatchSize(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_setMergedBatches : public ::omero::api::AMD_Search_setMergedBatches, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_setMergedBatches(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_isMergedBatches : public ::omero::api::AMD_Search_isMergedBatches, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_isMergedBatches(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_setCaseSentivice : public ::omero::api::AMD_Search_setCaseSentivice, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_setCaseSentivice(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_isCaseSensitive : public ::omero::api::AMD_Search_isCaseSensitive, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_isCaseSensitive(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_setUseProjections : public ::omero::api::AMD_Search_setUseProjections, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_setUseProjections(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_isUseProjections : public ::omero::api::AMD_Search_isUseProjections, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_isUseProjections(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_setReturnUnloaded : public ::omero::api::AMD_Search_setReturnUnloaded, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_setReturnUnloaded(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_isReturnUnloaded : public ::omero::api::AMD_Search_isReturnUnloaded, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_isReturnUnloaded(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_setAllowLeadingWildcard : public ::omero::api::AMD_Search_setAllowLeadingWildcard, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_setAllowLeadingWildcard(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_isAllowLeadingWildcard : public ::omero::api::AMD_Search_isAllowLeadingWildcard, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_isAllowLeadingWildcard(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_onlyType : public ::omero::api::AMD_Search_onlyType, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_onlyType(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_onlyTypes : public ::omero::api::AMD_Search_onlyTypes, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_onlyTypes(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_allTypes : public ::omero::api::AMD_Search_allTypes, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_allTypes(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_onlyIds : public ::omero::api::AMD_Search_onlyIds, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_onlyIds(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_onlyOwnedBy : public ::omero::api::AMD_Search_onlyOwnedBy, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_onlyOwnedBy(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_notOwnedBy : public ::omero::api::AMD_Search_notOwnedBy, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_notOwnedBy(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_onlyCreatedBetween : public ::omero::api::AMD_Search_onlyCreatedBetween, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_onlyCreatedBetween(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_onlyModifiedBetween : public ::omero::api::AMD_Search_onlyModifiedBetween, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_onlyModifiedBetween(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_onlyAnnotatedBetween : public ::omero::api::AMD_Search_onlyAnnotatedBetween, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_onlyAnnotatedBetween(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_onlyAnnotatedBy : public ::omero::api::AMD_Search_onlyAnnotatedBy, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_onlyAnnotatedBy(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_notAnnotatedBy : public ::omero::api::AMD_Search_notAnnotatedBy, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_notAnnotatedBy(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_onlyAnnotatedWith : public ::omero::api::AMD_Search_onlyAnnotatedWith, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_onlyAnnotatedWith(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_addOrderByAsc : public ::omero::api::AMD_Search_addOrderByAsc, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_addOrderByAsc(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_addOrderByDesc : public ::omero::api::AMD_Search_addOrderByDesc, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_addOrderByDesc(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_unordered : public ::omero::api::AMD_Search_unordered, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_unordered(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_fetchAnnotations : public ::omero::api::AMD_Search_fetchAnnotations, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_fetchAnnotations(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_fetchAlso : public ::omero::api::AMD_Search_fetchAlso, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_fetchAlso(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_resetDefaults : public ::omero::api::AMD_Search_resetDefaults, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_resetDefaults(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_byGroupForTags : public ::omero::api::AMD_Search_byGroupForTags, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_byGroupForTags(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_byTagForGroups : public ::omero::api::AMD_Search_byTagForGroups, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_byTagForGroups(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_byFullText : public ::omero::api::AMD_Search_byFullText, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_byFullText(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_byLuceneQueryBuilder : public ::omero::api::AMD_Search_byLuceneQueryBuilder, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_byLuceneQueryBuilder(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_bySimilarTerms : public ::omero::api::AMD_Search_bySimilarTerms, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_bySimilarTerms(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_byHqlQuery : public ::omero::api::AMD_Search_byHqlQuery, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_byHqlQuery(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_bySomeMustNone : public ::omero::api::AMD_Search_bySomeMustNone, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_bySomeMustNone(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_byAnnotatedWith : public ::omero::api::AMD_Search_byAnnotatedWith, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_byAnnotatedWith(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_clearQueries : public ::omero::api::AMD_Search_clearQueries, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_clearQueries(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_and : public ::omero::api::AMD_Search_and, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_and(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_or : public ::omero::api::AMD_Search_or, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_or(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_not : public ::omero::api::AMD_Search_not, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_not(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_hasNext : public ::omero::api::AMD_Search_hasNext, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_hasNext(::IceInternal::Incoming&);

    virtual void ice_response(bool);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_next : public ::omero::api::AMD_Search_next, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_next(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::model::IObjectPtr&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_results : public ::omero::api::AMD_Search_results, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_results(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::api::IObjectList&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_currentMetadata : public ::omero::api::AMD_Search_currentMetadata, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_currentMetadata(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::api::SearchMetadata&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_currentMetadataList : public ::omero::api::AMD_Search_currentMetadataList, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_currentMetadataList(::IceInternal::Incoming&);

    virtual void ice_response(const ::omero::api::SearchMetadataList&);
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

class AMD_Search_remove : public ::omero::api::AMD_Search_remove, public ::IceInternal::IncomingAsync
{
public:

    AMD_Search_remove(::IceInternal::Incoming&);

    virtual void ice_response();
    virtual void ice_exception(const ::std::exception&);
#if defined(__BCPLUSPLUS__)
    // COMPILERFIX: Avoid compiler warnings with C++Builder 2010
    virtual void ice_exception()
    {
        ::IceInternal::IncomingAsync::ice_exception();
    }
#endif
};

}

}

}

namespace omero
{

namespace api
{

class Callback_Search_activeQueries_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_activeQueries_Base> Callback_Search_activeQueriesPtr;

class Callback_Search_setBatchSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_setBatchSize_Base> Callback_Search_setBatchSizePtr;

class Callback_Search_getBatchSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_getBatchSize_Base> Callback_Search_getBatchSizePtr;

class Callback_Search_setMergedBatches_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_setMergedBatches_Base> Callback_Search_setMergedBatchesPtr;

class Callback_Search_isMergedBatches_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_isMergedBatches_Base> Callback_Search_isMergedBatchesPtr;

class Callback_Search_setCaseSentivice_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_setCaseSentivice_Base> Callback_Search_setCaseSentivicePtr;

class Callback_Search_isCaseSensitive_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_isCaseSensitive_Base> Callback_Search_isCaseSensitivePtr;

class Callback_Search_setUseProjections_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_setUseProjections_Base> Callback_Search_setUseProjectionsPtr;

class Callback_Search_isUseProjections_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_isUseProjections_Base> Callback_Search_isUseProjectionsPtr;

class Callback_Search_setReturnUnloaded_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_setReturnUnloaded_Base> Callback_Search_setReturnUnloadedPtr;

class Callback_Search_isReturnUnloaded_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_isReturnUnloaded_Base> Callback_Search_isReturnUnloadedPtr;

class Callback_Search_setAllowLeadingWildcard_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_setAllowLeadingWildcard_Base> Callback_Search_setAllowLeadingWildcardPtr;

class Callback_Search_isAllowLeadingWildcard_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_isAllowLeadingWildcard_Base> Callback_Search_isAllowLeadingWildcardPtr;

class Callback_Search_onlyType_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_onlyType_Base> Callback_Search_onlyTypePtr;

class Callback_Search_onlyTypes_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_onlyTypes_Base> Callback_Search_onlyTypesPtr;

class Callback_Search_allTypes_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_allTypes_Base> Callback_Search_allTypesPtr;

class Callback_Search_onlyIds_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_onlyIds_Base> Callback_Search_onlyIdsPtr;

class Callback_Search_onlyOwnedBy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_onlyOwnedBy_Base> Callback_Search_onlyOwnedByPtr;

class Callback_Search_notOwnedBy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_notOwnedBy_Base> Callback_Search_notOwnedByPtr;

class Callback_Search_onlyCreatedBetween_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_onlyCreatedBetween_Base> Callback_Search_onlyCreatedBetweenPtr;

class Callback_Search_onlyModifiedBetween_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_onlyModifiedBetween_Base> Callback_Search_onlyModifiedBetweenPtr;

class Callback_Search_onlyAnnotatedBetween_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_onlyAnnotatedBetween_Base> Callback_Search_onlyAnnotatedBetweenPtr;

class Callback_Search_onlyAnnotatedBy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_onlyAnnotatedBy_Base> Callback_Search_onlyAnnotatedByPtr;

class Callback_Search_notAnnotatedBy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_notAnnotatedBy_Base> Callback_Search_notAnnotatedByPtr;

class Callback_Search_onlyAnnotatedWith_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_onlyAnnotatedWith_Base> Callback_Search_onlyAnnotatedWithPtr;

class Callback_Search_addOrderByAsc_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_addOrderByAsc_Base> Callback_Search_addOrderByAscPtr;

class Callback_Search_addOrderByDesc_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_addOrderByDesc_Base> Callback_Search_addOrderByDescPtr;

class Callback_Search_unordered_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_unordered_Base> Callback_Search_unorderedPtr;

class Callback_Search_fetchAnnotations_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_fetchAnnotations_Base> Callback_Search_fetchAnnotationsPtr;

class Callback_Search_fetchAlso_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_fetchAlso_Base> Callback_Search_fetchAlsoPtr;

class Callback_Search_resetDefaults_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_resetDefaults_Base> Callback_Search_resetDefaultsPtr;

class Callback_Search_byGroupForTags_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_byGroupForTags_Base> Callback_Search_byGroupForTagsPtr;

class Callback_Search_byTagForGroups_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_byTagForGroups_Base> Callback_Search_byTagForGroupsPtr;

class Callback_Search_byFullText_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_byFullText_Base> Callback_Search_byFullTextPtr;

class Callback_Search_byLuceneQueryBuilder_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_byLuceneQueryBuilder_Base> Callback_Search_byLuceneQueryBuilderPtr;

class Callback_Search_bySimilarTerms_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_bySimilarTerms_Base> Callback_Search_bySimilarTermsPtr;

class Callback_Search_byHqlQuery_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_byHqlQuery_Base> Callback_Search_byHqlQueryPtr;

class Callback_Search_bySomeMustNone_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_bySomeMustNone_Base> Callback_Search_bySomeMustNonePtr;

class Callback_Search_byAnnotatedWith_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_byAnnotatedWith_Base> Callback_Search_byAnnotatedWithPtr;

class Callback_Search_clearQueries_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_clearQueries_Base> Callback_Search_clearQueriesPtr;

class Callback_Search_and_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_and_Base> Callback_Search_andPtr;

class Callback_Search_or_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_or_Base> Callback_Search_orPtr;

class Callback_Search_not_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_not_Base> Callback_Search_notPtr;

class Callback_Search_hasNext_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_hasNext_Base> Callback_Search_hasNextPtr;

class Callback_Search_next_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_next_Base> Callback_Search_nextPtr;

class Callback_Search_results_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_results_Base> Callback_Search_resultsPtr;

class Callback_Search_currentMetadata_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_currentMetadata_Base> Callback_Search_currentMetadataPtr;

class Callback_Search_currentMetadataList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_currentMetadataList_Base> Callback_Search_currentMetadataListPtr;

class Callback_Search_remove_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Search_remove_Base> Callback_Search_removePtr;

}

}

namespace IceProxy
{

namespace omero
{

namespace api
{

class Search : virtual public ::IceProxy::omero::api::StatefulServiceInterface
{
public:

    ::Ice::Int activeQueries()
    {
        return activeQueries(0);
    }
    ::Ice::Int activeQueries(const ::Ice::Context& __ctx)
    {
        return activeQueries(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_activeQueries()
    {
        return begin_activeQueries(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_activeQueries(const ::Ice::Context& __ctx)
    {
        return begin_activeQueries(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_activeQueries(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_activeQueries(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_activeQueries(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_activeQueries(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_activeQueries(const ::omero::api::Callback_Search_activeQueriesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_activeQueries(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_activeQueries(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_activeQueriesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_activeQueries(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_activeQueries(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int activeQueries(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_activeQueries(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool activeQueries_async(const ::omero::api::AMI_Search_activeQueriesPtr&);
    bool activeQueries_async(const ::omero::api::AMI_Search_activeQueriesPtr&, const ::Ice::Context&);

    void setBatchSize(::Ice::Int size)
    {
        setBatchSize(size, 0);
    }
    void setBatchSize(::Ice::Int size, const ::Ice::Context& __ctx)
    {
        setBatchSize(size, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setBatchSize(::Ice::Int size)
    {
        return begin_setBatchSize(size, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setBatchSize(::Ice::Int size, const ::Ice::Context& __ctx)
    {
        return begin_setBatchSize(size, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setBatchSize(::Ice::Int size, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBatchSize(size, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBatchSize(::Ice::Int size, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBatchSize(size, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBatchSize(::Ice::Int size, const ::omero::api::Callback_Search_setBatchSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBatchSize(size, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setBatchSize(::Ice::Int size, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_setBatchSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setBatchSize(size, &__ctx, __del, __cookie);
    }

    void end_setBatchSize(const ::Ice::AsyncResultPtr&);
    
private:

    void setBatchSize(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setBatchSize(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setBatchSize_async(const ::omero::api::AMI_Search_setBatchSizePtr&, ::Ice::Int);
    bool setBatchSize_async(const ::omero::api::AMI_Search_setBatchSizePtr&, ::Ice::Int, const ::Ice::Context&);

    ::Ice::Int getBatchSize()
    {
        return getBatchSize(0);
    }
    ::Ice::Int getBatchSize(const ::Ice::Context& __ctx)
    {
        return getBatchSize(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getBatchSize()
    {
        return begin_getBatchSize(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBatchSize(const ::Ice::Context& __ctx)
    {
        return begin_getBatchSize(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getBatchSize(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBatchSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBatchSize(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBatchSize(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBatchSize(const ::omero::api::Callback_Search_getBatchSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBatchSize(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getBatchSize(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_getBatchSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getBatchSize(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getBatchSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getBatchSize(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getBatchSize(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getBatchSize_async(const ::omero::api::AMI_Search_getBatchSizePtr&);
    bool getBatchSize_async(const ::omero::api::AMI_Search_getBatchSizePtr&, const ::Ice::Context&);

    void setMergedBatches(bool merge)
    {
        setMergedBatches(merge, 0);
    }
    void setMergedBatches(bool merge, const ::Ice::Context& __ctx)
    {
        setMergedBatches(merge, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setMergedBatches(bool merge)
    {
        return begin_setMergedBatches(merge, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMergedBatches(bool merge, const ::Ice::Context& __ctx)
    {
        return begin_setMergedBatches(merge, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setMergedBatches(bool merge, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMergedBatches(merge, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMergedBatches(bool merge, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMergedBatches(merge, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMergedBatches(bool merge, const ::omero::api::Callback_Search_setMergedBatchesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMergedBatches(merge, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setMergedBatches(bool merge, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_setMergedBatchesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setMergedBatches(merge, &__ctx, __del, __cookie);
    }

    void end_setMergedBatches(const ::Ice::AsyncResultPtr&);
    
private:

    void setMergedBatches(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setMergedBatches(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setMergedBatches_async(const ::omero::api::AMI_Search_setMergedBatchesPtr&, bool);
    bool setMergedBatches_async(const ::omero::api::AMI_Search_setMergedBatchesPtr&, bool, const ::Ice::Context&);

    bool isMergedBatches()
    {
        return isMergedBatches(0);
    }
    bool isMergedBatches(const ::Ice::Context& __ctx)
    {
        return isMergedBatches(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_isMergedBatches()
    {
        return begin_isMergedBatches(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isMergedBatches(const ::Ice::Context& __ctx)
    {
        return begin_isMergedBatches(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isMergedBatches(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isMergedBatches(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isMergedBatches(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isMergedBatches(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isMergedBatches(const ::omero::api::Callback_Search_isMergedBatchesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isMergedBatches(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isMergedBatches(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_isMergedBatchesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isMergedBatches(&__ctx, __del, __cookie);
    }

    bool end_isMergedBatches(const ::Ice::AsyncResultPtr&);
    
private:

    bool isMergedBatches(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isMergedBatches(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool isMergedBatches_async(const ::omero::api::AMI_Search_isMergedBatchesPtr&);
    bool isMergedBatches_async(const ::omero::api::AMI_Search_isMergedBatchesPtr&, const ::Ice::Context&);

    void setCaseSentivice(bool caseSensitive)
    {
        setCaseSentivice(caseSensitive, 0);
    }
    void setCaseSentivice(bool caseSensitive, const ::Ice::Context& __ctx)
    {
        setCaseSentivice(caseSensitive, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setCaseSentivice(bool caseSensitive)
    {
        return begin_setCaseSentivice(caseSensitive, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCaseSentivice(bool caseSensitive, const ::Ice::Context& __ctx)
    {
        return begin_setCaseSentivice(caseSensitive, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCaseSentivice(bool caseSensitive, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCaseSentivice(caseSensitive, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCaseSentivice(bool caseSensitive, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCaseSentivice(caseSensitive, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCaseSentivice(bool caseSensitive, const ::omero::api::Callback_Search_setCaseSentivicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCaseSentivice(caseSensitive, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setCaseSentivice(bool caseSensitive, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_setCaseSentivicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setCaseSentivice(caseSensitive, &__ctx, __del, __cookie);
    }

    void end_setCaseSentivice(const ::Ice::AsyncResultPtr&);
    
private:

    void setCaseSentivice(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setCaseSentivice(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setCaseSentivice_async(const ::omero::api::AMI_Search_setCaseSentivicePtr&, bool);
    bool setCaseSentivice_async(const ::omero::api::AMI_Search_setCaseSentivicePtr&, bool, const ::Ice::Context&);

    bool isCaseSensitive()
    {
        return isCaseSensitive(0);
    }
    bool isCaseSensitive(const ::Ice::Context& __ctx)
    {
        return isCaseSensitive(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_isCaseSensitive()
    {
        return begin_isCaseSensitive(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isCaseSensitive(const ::Ice::Context& __ctx)
    {
        return begin_isCaseSensitive(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isCaseSensitive(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isCaseSensitive(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isCaseSensitive(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isCaseSensitive(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isCaseSensitive(const ::omero::api::Callback_Search_isCaseSensitivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isCaseSensitive(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isCaseSensitive(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_isCaseSensitivePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isCaseSensitive(&__ctx, __del, __cookie);
    }

    bool end_isCaseSensitive(const ::Ice::AsyncResultPtr&);
    
private:

    bool isCaseSensitive(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isCaseSensitive(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool isCaseSensitive_async(const ::omero::api::AMI_Search_isCaseSensitivePtr&);
    bool isCaseSensitive_async(const ::omero::api::AMI_Search_isCaseSensitivePtr&, const ::Ice::Context&);

    void setUseProjections(bool useProjections)
    {
        setUseProjections(useProjections, 0);
    }
    void setUseProjections(bool useProjections, const ::Ice::Context& __ctx)
    {
        setUseProjections(useProjections, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setUseProjections(bool useProjections)
    {
        return begin_setUseProjections(useProjections, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setUseProjections(bool useProjections, const ::Ice::Context& __ctx)
    {
        return begin_setUseProjections(useProjections, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setUseProjections(bool useProjections, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setUseProjections(useProjections, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setUseProjections(bool useProjections, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setUseProjections(useProjections, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setUseProjections(bool useProjections, const ::omero::api::Callback_Search_setUseProjectionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setUseProjections(useProjections, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setUseProjections(bool useProjections, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_setUseProjectionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setUseProjections(useProjections, &__ctx, __del, __cookie);
    }

    void end_setUseProjections(const ::Ice::AsyncResultPtr&);
    
private:

    void setUseProjections(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setUseProjections(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setUseProjections_async(const ::omero::api::AMI_Search_setUseProjectionsPtr&, bool);
    bool setUseProjections_async(const ::omero::api::AMI_Search_setUseProjectionsPtr&, bool, const ::Ice::Context&);

    bool isUseProjections()
    {
        return isUseProjections(0);
    }
    bool isUseProjections(const ::Ice::Context& __ctx)
    {
        return isUseProjections(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_isUseProjections()
    {
        return begin_isUseProjections(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isUseProjections(const ::Ice::Context& __ctx)
    {
        return begin_isUseProjections(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isUseProjections(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isUseProjections(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isUseProjections(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isUseProjections(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isUseProjections(const ::omero::api::Callback_Search_isUseProjectionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isUseProjections(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isUseProjections(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_isUseProjectionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isUseProjections(&__ctx, __del, __cookie);
    }

    bool end_isUseProjections(const ::Ice::AsyncResultPtr&);
    
private:

    bool isUseProjections(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isUseProjections(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool isUseProjections_async(const ::omero::api::AMI_Search_isUseProjectionsPtr&);
    bool isUseProjections_async(const ::omero::api::AMI_Search_isUseProjectionsPtr&, const ::Ice::Context&);

    void setReturnUnloaded(bool returnUnloaded)
    {
        setReturnUnloaded(returnUnloaded, 0);
    }
    void setReturnUnloaded(bool returnUnloaded, const ::Ice::Context& __ctx)
    {
        setReturnUnloaded(returnUnloaded, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setReturnUnloaded(bool returnUnloaded)
    {
        return begin_setReturnUnloaded(returnUnloaded, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setReturnUnloaded(bool returnUnloaded, const ::Ice::Context& __ctx)
    {
        return begin_setReturnUnloaded(returnUnloaded, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setReturnUnloaded(bool returnUnloaded, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setReturnUnloaded(returnUnloaded, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setReturnUnloaded(bool returnUnloaded, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setReturnUnloaded(returnUnloaded, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setReturnUnloaded(bool returnUnloaded, const ::omero::api::Callback_Search_setReturnUnloadedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setReturnUnloaded(returnUnloaded, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setReturnUnloaded(bool returnUnloaded, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_setReturnUnloadedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setReturnUnloaded(returnUnloaded, &__ctx, __del, __cookie);
    }

    void end_setReturnUnloaded(const ::Ice::AsyncResultPtr&);
    
private:

    void setReturnUnloaded(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setReturnUnloaded(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setReturnUnloaded_async(const ::omero::api::AMI_Search_setReturnUnloadedPtr&, bool);
    bool setReturnUnloaded_async(const ::omero::api::AMI_Search_setReturnUnloadedPtr&, bool, const ::Ice::Context&);

    bool isReturnUnloaded()
    {
        return isReturnUnloaded(0);
    }
    bool isReturnUnloaded(const ::Ice::Context& __ctx)
    {
        return isReturnUnloaded(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_isReturnUnloaded()
    {
        return begin_isReturnUnloaded(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isReturnUnloaded(const ::Ice::Context& __ctx)
    {
        return begin_isReturnUnloaded(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isReturnUnloaded(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isReturnUnloaded(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isReturnUnloaded(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isReturnUnloaded(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isReturnUnloaded(const ::omero::api::Callback_Search_isReturnUnloadedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isReturnUnloaded(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isReturnUnloaded(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_isReturnUnloadedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isReturnUnloaded(&__ctx, __del, __cookie);
    }

    bool end_isReturnUnloaded(const ::Ice::AsyncResultPtr&);
    
private:

    bool isReturnUnloaded(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isReturnUnloaded(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool isReturnUnloaded_async(const ::omero::api::AMI_Search_isReturnUnloadedPtr&);
    bool isReturnUnloaded_async(const ::omero::api::AMI_Search_isReturnUnloadedPtr&, const ::Ice::Context&);

    void setAllowLeadingWildcard(bool allowLeadingWildcard)
    {
        setAllowLeadingWildcard(allowLeadingWildcard, 0);
    }
    void setAllowLeadingWildcard(bool allowLeadingWildcard, const ::Ice::Context& __ctx)
    {
        setAllowLeadingWildcard(allowLeadingWildcard, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setAllowLeadingWildcard(bool allowLeadingWildcard)
    {
        return begin_setAllowLeadingWildcard(allowLeadingWildcard, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAllowLeadingWildcard(bool allowLeadingWildcard, const ::Ice::Context& __ctx)
    {
        return begin_setAllowLeadingWildcard(allowLeadingWildcard, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setAllowLeadingWildcard(bool allowLeadingWildcard, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAllowLeadingWildcard(allowLeadingWildcard, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAllowLeadingWildcard(bool allowLeadingWildcard, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAllowLeadingWildcard(allowLeadingWildcard, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAllowLeadingWildcard(bool allowLeadingWildcard, const ::omero::api::Callback_Search_setAllowLeadingWildcardPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAllowLeadingWildcard(allowLeadingWildcard, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setAllowLeadingWildcard(bool allowLeadingWildcard, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_setAllowLeadingWildcardPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setAllowLeadingWildcard(allowLeadingWildcard, &__ctx, __del, __cookie);
    }

    void end_setAllowLeadingWildcard(const ::Ice::AsyncResultPtr&);
    
private:

    void setAllowLeadingWildcard(bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setAllowLeadingWildcard(bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool setAllowLeadingWildcard_async(const ::omero::api::AMI_Search_setAllowLeadingWildcardPtr&, bool);
    bool setAllowLeadingWildcard_async(const ::omero::api::AMI_Search_setAllowLeadingWildcardPtr&, bool, const ::Ice::Context&);

    bool isAllowLeadingWildcard()
    {
        return isAllowLeadingWildcard(0);
    }
    bool isAllowLeadingWildcard(const ::Ice::Context& __ctx)
    {
        return isAllowLeadingWildcard(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_isAllowLeadingWildcard()
    {
        return begin_isAllowLeadingWildcard(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isAllowLeadingWildcard(const ::Ice::Context& __ctx)
    {
        return begin_isAllowLeadingWildcard(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isAllowLeadingWildcard(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isAllowLeadingWildcard(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isAllowLeadingWildcard(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isAllowLeadingWildcard(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isAllowLeadingWildcard(const ::omero::api::Callback_Search_isAllowLeadingWildcardPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isAllowLeadingWildcard(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isAllowLeadingWildcard(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_isAllowLeadingWildcardPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isAllowLeadingWildcard(&__ctx, __del, __cookie);
    }

    bool end_isAllowLeadingWildcard(const ::Ice::AsyncResultPtr&);
    
private:

    bool isAllowLeadingWildcard(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isAllowLeadingWildcard(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool isAllowLeadingWildcard_async(const ::omero::api::AMI_Search_isAllowLeadingWildcardPtr&);
    bool isAllowLeadingWildcard_async(const ::omero::api::AMI_Search_isAllowLeadingWildcardPtr&, const ::Ice::Context&);

    void onlyType(const ::std::string& klass)
    {
        onlyType(klass, 0);
    }
    void onlyType(const ::std::string& klass, const ::Ice::Context& __ctx)
    {
        onlyType(klass, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_onlyType(const ::std::string& klass)
    {
        return begin_onlyType(klass, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyType(const ::std::string& klass, const ::Ice::Context& __ctx)
    {
        return begin_onlyType(klass, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyType(const ::std::string& klass, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyType(klass, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyType(const ::std::string& klass, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyType(klass, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyType(const ::std::string& klass, const ::omero::api::Callback_Search_onlyTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyType(klass, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyType(const ::std::string& klass, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_onlyTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyType(klass, &__ctx, __del, __cookie);
    }

    void end_onlyType(const ::Ice::AsyncResultPtr&);
    
private:

    void onlyType(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onlyType(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool onlyType_async(const ::omero::api::AMI_Search_onlyTypePtr&, const ::std::string&);
    bool onlyType_async(const ::omero::api::AMI_Search_onlyTypePtr&, const ::std::string&, const ::Ice::Context&);

    void onlyTypes(const ::omero::api::StringSet& classes)
    {
        onlyTypes(classes, 0);
    }
    void onlyTypes(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx)
    {
        onlyTypes(classes, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_onlyTypes(const ::omero::api::StringSet& classes)
    {
        return begin_onlyTypes(classes, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyTypes(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx)
    {
        return begin_onlyTypes(classes, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyTypes(const ::omero::api::StringSet& classes, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyTypes(classes, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyTypes(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyTypes(classes, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyTypes(const ::omero::api::StringSet& classes, const ::omero::api::Callback_Search_onlyTypesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyTypes(classes, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyTypes(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_onlyTypesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyTypes(classes, &__ctx, __del, __cookie);
    }

    void end_onlyTypes(const ::Ice::AsyncResultPtr&);
    
private:

    void onlyTypes(const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onlyTypes(const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool onlyTypes_async(const ::omero::api::AMI_Search_onlyTypesPtr&, const ::omero::api::StringSet&);
    bool onlyTypes_async(const ::omero::api::AMI_Search_onlyTypesPtr&, const ::omero::api::StringSet&, const ::Ice::Context&);

    void allTypes()
    {
        allTypes(0);
    }
    void allTypes(const ::Ice::Context& __ctx)
    {
        allTypes(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_allTypes()
    {
        return begin_allTypes(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_allTypes(const ::Ice::Context& __ctx)
    {
        return begin_allTypes(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_allTypes(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allTypes(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_allTypes(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allTypes(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_allTypes(const ::omero::api::Callback_Search_allTypesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allTypes(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_allTypes(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_allTypesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allTypes(&__ctx, __del, __cookie);
    }

    void end_allTypes(const ::Ice::AsyncResultPtr&);
    
private:

    void allTypes(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_allTypes(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool allTypes_async(const ::omero::api::AMI_Search_allTypesPtr&);
    bool allTypes_async(const ::omero::api::AMI_Search_allTypesPtr&, const ::Ice::Context&);

    void onlyIds(const ::omero::sys::LongList& ids)
    {
        onlyIds(ids, 0);
    }
    void onlyIds(const ::omero::sys::LongList& ids, const ::Ice::Context& __ctx)
    {
        onlyIds(ids, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_onlyIds(const ::omero::sys::LongList& ids)
    {
        return begin_onlyIds(ids, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyIds(const ::omero::sys::LongList& ids, const ::Ice::Context& __ctx)
    {
        return begin_onlyIds(ids, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyIds(const ::omero::sys::LongList& ids, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyIds(ids, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyIds(const ::omero::sys::LongList& ids, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyIds(ids, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyIds(const ::omero::sys::LongList& ids, const ::omero::api::Callback_Search_onlyIdsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyIds(ids, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyIds(const ::omero::sys::LongList& ids, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_onlyIdsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyIds(ids, &__ctx, __del, __cookie);
    }

    void end_onlyIds(const ::Ice::AsyncResultPtr&);
    
private:

    void onlyIds(const ::omero::sys::LongList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onlyIds(const ::omero::sys::LongList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool onlyIds_async(const ::omero::api::AMI_Search_onlyIdsPtr&, const ::omero::sys::LongList&);
    bool onlyIds_async(const ::omero::api::AMI_Search_onlyIdsPtr&, const ::omero::sys::LongList&, const ::Ice::Context&);

    void onlyOwnedBy(const ::omero::model::DetailsPtr& d)
    {
        onlyOwnedBy(d, 0);
    }
    void onlyOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx)
    {
        onlyOwnedBy(d, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_onlyOwnedBy(const ::omero::model::DetailsPtr& d)
    {
        return begin_onlyOwnedBy(d, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx)
    {
        return begin_onlyOwnedBy(d, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyOwnedBy(d, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyOwnedBy(d, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyOwnedBy(const ::omero::model::DetailsPtr& d, const ::omero::api::Callback_Search_onlyOwnedByPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyOwnedBy(d, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_onlyOwnedByPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyOwnedBy(d, &__ctx, __del, __cookie);
    }

    void end_onlyOwnedBy(const ::Ice::AsyncResultPtr&);
    
private:

    void onlyOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onlyOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool onlyOwnedBy_async(const ::omero::api::AMI_Search_onlyOwnedByPtr&, const ::omero::model::DetailsPtr&);
    bool onlyOwnedBy_async(const ::omero::api::AMI_Search_onlyOwnedByPtr&, const ::omero::model::DetailsPtr&, const ::Ice::Context&);

    void notOwnedBy(const ::omero::model::DetailsPtr& d)
    {
        notOwnedBy(d, 0);
    }
    void notOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx)
    {
        notOwnedBy(d, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_notOwnedBy(const ::omero::model::DetailsPtr& d)
    {
        return begin_notOwnedBy(d, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_notOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx)
    {
        return begin_notOwnedBy(d, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_notOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_notOwnedBy(d, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_notOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_notOwnedBy(d, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_notOwnedBy(const ::omero::model::DetailsPtr& d, const ::omero::api::Callback_Search_notOwnedByPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_notOwnedBy(d, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_notOwnedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_notOwnedByPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_notOwnedBy(d, &__ctx, __del, __cookie);
    }

    void end_notOwnedBy(const ::Ice::AsyncResultPtr&);
    
private:

    void notOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_notOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool notOwnedBy_async(const ::omero::api::AMI_Search_notOwnedByPtr&, const ::omero::model::DetailsPtr&);
    bool notOwnedBy_async(const ::omero::api::AMI_Search_notOwnedByPtr&, const ::omero::model::DetailsPtr&, const ::Ice::Context&);

    void onlyCreatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop)
    {
        onlyCreatedBetween(start, stop, 0);
    }
    void onlyCreatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx)
    {
        onlyCreatedBetween(start, stop, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_onlyCreatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop)
    {
        return begin_onlyCreatedBetween(start, stop, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyCreatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx)
    {
        return begin_onlyCreatedBetween(start, stop, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyCreatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyCreatedBetween(start, stop, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyCreatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyCreatedBetween(start, stop, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyCreatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::omero::api::Callback_Search_onlyCreatedBetweenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyCreatedBetween(start, stop, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyCreatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_onlyCreatedBetweenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyCreatedBetween(start, stop, &__ctx, __del, __cookie);
    }

    void end_onlyCreatedBetween(const ::Ice::AsyncResultPtr&);
    
private:

    void onlyCreatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onlyCreatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool onlyCreatedBetween_async(const ::omero::api::AMI_Search_onlyCreatedBetweenPtr&, const ::omero::RTimePtr&, const ::omero::RTimePtr&);
    bool onlyCreatedBetween_async(const ::omero::api::AMI_Search_onlyCreatedBetweenPtr&, const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context&);

    void onlyModifiedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop)
    {
        onlyModifiedBetween(start, stop, 0);
    }
    void onlyModifiedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx)
    {
        onlyModifiedBetween(start, stop, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_onlyModifiedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop)
    {
        return begin_onlyModifiedBetween(start, stop, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyModifiedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx)
    {
        return begin_onlyModifiedBetween(start, stop, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyModifiedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyModifiedBetween(start, stop, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyModifiedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyModifiedBetween(start, stop, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyModifiedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::omero::api::Callback_Search_onlyModifiedBetweenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyModifiedBetween(start, stop, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyModifiedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_onlyModifiedBetweenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyModifiedBetween(start, stop, &__ctx, __del, __cookie);
    }

    void end_onlyModifiedBetween(const ::Ice::AsyncResultPtr&);
    
private:

    void onlyModifiedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onlyModifiedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool onlyModifiedBetween_async(const ::omero::api::AMI_Search_onlyModifiedBetweenPtr&, const ::omero::RTimePtr&, const ::omero::RTimePtr&);
    bool onlyModifiedBetween_async(const ::omero::api::AMI_Search_onlyModifiedBetweenPtr&, const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context&);

    void onlyAnnotatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop)
    {
        onlyAnnotatedBetween(start, stop, 0);
    }
    void onlyAnnotatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx)
    {
        onlyAnnotatedBetween(start, stop, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop)
    {
        return begin_onlyAnnotatedBetween(start, stop, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx)
    {
        return begin_onlyAnnotatedBetween(start, stop, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedBetween(start, stop, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedBetween(start, stop, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::omero::api::Callback_Search_onlyAnnotatedBetweenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedBetween(start, stop, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBetween(const ::omero::RTimePtr& start, const ::omero::RTimePtr& stop, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_onlyAnnotatedBetweenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedBetween(start, stop, &__ctx, __del, __cookie);
    }

    void end_onlyAnnotatedBetween(const ::Ice::AsyncResultPtr&);
    
private:

    void onlyAnnotatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onlyAnnotatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool onlyAnnotatedBetween_async(const ::omero::api::AMI_Search_onlyAnnotatedBetweenPtr&, const ::omero::RTimePtr&, const ::omero::RTimePtr&);
    bool onlyAnnotatedBetween_async(const ::omero::api::AMI_Search_onlyAnnotatedBetweenPtr&, const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context&);

    void onlyAnnotatedBy(const ::omero::model::DetailsPtr& d)
    {
        onlyAnnotatedBy(d, 0);
    }
    void onlyAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx)
    {
        onlyAnnotatedBy(d, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBy(const ::omero::model::DetailsPtr& d)
    {
        return begin_onlyAnnotatedBy(d, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx)
    {
        return begin_onlyAnnotatedBy(d, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedBy(d, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedBy(d, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::omero::api::Callback_Search_onlyAnnotatedByPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedBy(d, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_onlyAnnotatedByPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedBy(d, &__ctx, __del, __cookie);
    }

    void end_onlyAnnotatedBy(const ::Ice::AsyncResultPtr&);
    
private:

    void onlyAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onlyAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool onlyAnnotatedBy_async(const ::omero::api::AMI_Search_onlyAnnotatedByPtr&, const ::omero::model::DetailsPtr&);
    bool onlyAnnotatedBy_async(const ::omero::api::AMI_Search_onlyAnnotatedByPtr&, const ::omero::model::DetailsPtr&, const ::Ice::Context&);

    void notAnnotatedBy(const ::omero::model::DetailsPtr& d)
    {
        notAnnotatedBy(d, 0);
    }
    void notAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx)
    {
        notAnnotatedBy(d, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_notAnnotatedBy(const ::omero::model::DetailsPtr& d)
    {
        return begin_notAnnotatedBy(d, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_notAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx)
    {
        return begin_notAnnotatedBy(d, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_notAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_notAnnotatedBy(d, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_notAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_notAnnotatedBy(d, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_notAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::omero::api::Callback_Search_notAnnotatedByPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_notAnnotatedBy(d, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_notAnnotatedBy(const ::omero::model::DetailsPtr& d, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_notAnnotatedByPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_notAnnotatedBy(d, &__ctx, __del, __cookie);
    }

    void end_notAnnotatedBy(const ::Ice::AsyncResultPtr&);
    
private:

    void notAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_notAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool notAnnotatedBy_async(const ::omero::api::AMI_Search_notAnnotatedByPtr&, const ::omero::model::DetailsPtr&);
    bool notAnnotatedBy_async(const ::omero::api::AMI_Search_notAnnotatedByPtr&, const ::omero::model::DetailsPtr&, const ::Ice::Context&);

    void onlyAnnotatedWith(const ::omero::api::StringSet& classes)
    {
        onlyAnnotatedWith(classes, 0);
    }
    void onlyAnnotatedWith(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx)
    {
        onlyAnnotatedWith(classes, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedWith(const ::omero::api::StringSet& classes)
    {
        return begin_onlyAnnotatedWith(classes, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedWith(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx)
    {
        return begin_onlyAnnotatedWith(classes, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedWith(const ::omero::api::StringSet& classes, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedWith(classes, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedWith(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedWith(classes, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedWith(const ::omero::api::StringSet& classes, const ::omero::api::Callback_Search_onlyAnnotatedWithPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedWith(classes, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_onlyAnnotatedWith(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_onlyAnnotatedWithPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_onlyAnnotatedWith(classes, &__ctx, __del, __cookie);
    }

    void end_onlyAnnotatedWith(const ::Ice::AsyncResultPtr&);
    
private:

    void onlyAnnotatedWith(const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_onlyAnnotatedWith(const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool onlyAnnotatedWith_async(const ::omero::api::AMI_Search_onlyAnnotatedWithPtr&, const ::omero::api::StringSet&);
    bool onlyAnnotatedWith_async(const ::omero::api::AMI_Search_onlyAnnotatedWithPtr&, const ::omero::api::StringSet&, const ::Ice::Context&);

    void addOrderByAsc(const ::std::string& path)
    {
        addOrderByAsc(path, 0);
    }
    void addOrderByAsc(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        addOrderByAsc(path, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addOrderByAsc(const ::std::string& path)
    {
        return begin_addOrderByAsc(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addOrderByAsc(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_addOrderByAsc(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addOrderByAsc(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addOrderByAsc(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addOrderByAsc(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addOrderByAsc(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addOrderByAsc(const ::std::string& path, const ::omero::api::Callback_Search_addOrderByAscPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addOrderByAsc(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addOrderByAsc(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_addOrderByAscPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addOrderByAsc(path, &__ctx, __del, __cookie);
    }

    void end_addOrderByAsc(const ::Ice::AsyncResultPtr&);
    
private:

    void addOrderByAsc(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addOrderByAsc(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool addOrderByAsc_async(const ::omero::api::AMI_Search_addOrderByAscPtr&, const ::std::string&);
    bool addOrderByAsc_async(const ::omero::api::AMI_Search_addOrderByAscPtr&, const ::std::string&, const ::Ice::Context&);

    void addOrderByDesc(const ::std::string& path)
    {
        addOrderByDesc(path, 0);
    }
    void addOrderByDesc(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        addOrderByDesc(path, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addOrderByDesc(const ::std::string& path)
    {
        return begin_addOrderByDesc(path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addOrderByDesc(const ::std::string& path, const ::Ice::Context& __ctx)
    {
        return begin_addOrderByDesc(path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addOrderByDesc(const ::std::string& path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addOrderByDesc(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addOrderByDesc(const ::std::string& path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addOrderByDesc(path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addOrderByDesc(const ::std::string& path, const ::omero::api::Callback_Search_addOrderByDescPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addOrderByDesc(path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addOrderByDesc(const ::std::string& path, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_addOrderByDescPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addOrderByDesc(path, &__ctx, __del, __cookie);
    }

    void end_addOrderByDesc(const ::Ice::AsyncResultPtr&);
    
private:

    void addOrderByDesc(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addOrderByDesc(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool addOrderByDesc_async(const ::omero::api::AMI_Search_addOrderByDescPtr&, const ::std::string&);
    bool addOrderByDesc_async(const ::omero::api::AMI_Search_addOrderByDescPtr&, const ::std::string&, const ::Ice::Context&);

    void unordered()
    {
        unordered(0);
    }
    void unordered(const ::Ice::Context& __ctx)
    {
        unordered(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_unordered()
    {
        return begin_unordered(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unordered(const ::Ice::Context& __ctx)
    {
        return begin_unordered(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unordered(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unordered(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unordered(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unordered(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unordered(const ::omero::api::Callback_Search_unorderedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unordered(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unordered(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_unorderedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unordered(&__ctx, __del, __cookie);
    }

    void end_unordered(const ::Ice::AsyncResultPtr&);
    
private:

    void unordered(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unordered(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool unordered_async(const ::omero::api::AMI_Search_unorderedPtr&);
    bool unordered_async(const ::omero::api::AMI_Search_unorderedPtr&, const ::Ice::Context&);

    void fetchAnnotations(const ::omero::api::StringSet& classes)
    {
        fetchAnnotations(classes, 0);
    }
    void fetchAnnotations(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx)
    {
        fetchAnnotations(classes, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_fetchAnnotations(const ::omero::api::StringSet& classes)
    {
        return begin_fetchAnnotations(classes, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fetchAnnotations(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx)
    {
        return begin_fetchAnnotations(classes, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fetchAnnotations(const ::omero::api::StringSet& classes, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchAnnotations(classes, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fetchAnnotations(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchAnnotations(classes, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fetchAnnotations(const ::omero::api::StringSet& classes, const ::omero::api::Callback_Search_fetchAnnotationsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchAnnotations(classes, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fetchAnnotations(const ::omero::api::StringSet& classes, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_fetchAnnotationsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchAnnotations(classes, &__ctx, __del, __cookie);
    }

    void end_fetchAnnotations(const ::Ice::AsyncResultPtr&);
    
private:

    void fetchAnnotations(const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fetchAnnotations(const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool fetchAnnotations_async(const ::omero::api::AMI_Search_fetchAnnotationsPtr&, const ::omero::api::StringSet&);
    bool fetchAnnotations_async(const ::omero::api::AMI_Search_fetchAnnotationsPtr&, const ::omero::api::StringSet&, const ::Ice::Context&);

    void fetchAlso(const ::omero::api::StringSet& fetches)
    {
        fetchAlso(fetches, 0);
    }
    void fetchAlso(const ::omero::api::StringSet& fetches, const ::Ice::Context& __ctx)
    {
        fetchAlso(fetches, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_fetchAlso(const ::omero::api::StringSet& fetches)
    {
        return begin_fetchAlso(fetches, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fetchAlso(const ::omero::api::StringSet& fetches, const ::Ice::Context& __ctx)
    {
        return begin_fetchAlso(fetches, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fetchAlso(const ::omero::api::StringSet& fetches, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchAlso(fetches, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fetchAlso(const ::omero::api::StringSet& fetches, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchAlso(fetches, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fetchAlso(const ::omero::api::StringSet& fetches, const ::omero::api::Callback_Search_fetchAlsoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchAlso(fetches, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fetchAlso(const ::omero::api::StringSet& fetches, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_fetchAlsoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchAlso(fetches, &__ctx, __del, __cookie);
    }

    void end_fetchAlso(const ::Ice::AsyncResultPtr&);
    
private:

    void fetchAlso(const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fetchAlso(const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool fetchAlso_async(const ::omero::api::AMI_Search_fetchAlsoPtr&, const ::omero::api::StringSet&);
    bool fetchAlso_async(const ::omero::api::AMI_Search_fetchAlsoPtr&, const ::omero::api::StringSet&, const ::Ice::Context&);

    void resetDefaults()
    {
        resetDefaults(0);
    }
    void resetDefaults(const ::Ice::Context& __ctx)
    {
        resetDefaults(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_resetDefaults()
    {
        return begin_resetDefaults(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_resetDefaults(const ::Ice::Context& __ctx)
    {
        return begin_resetDefaults(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_resetDefaults(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_resetDefaults(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_resetDefaults(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_resetDefaults(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_resetDefaults(const ::omero::api::Callback_Search_resetDefaultsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_resetDefaults(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_resetDefaults(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_resetDefaultsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_resetDefaults(&__ctx, __del, __cookie);
    }

    void end_resetDefaults(const ::Ice::AsyncResultPtr&);
    
private:

    void resetDefaults(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_resetDefaults(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool resetDefaults_async(const ::omero::api::AMI_Search_resetDefaultsPtr&);
    bool resetDefaults_async(const ::omero::api::AMI_Search_resetDefaultsPtr&, const ::Ice::Context&);

    void byGroupForTags(const ::std::string& group)
    {
        byGroupForTags(group, 0);
    }
    void byGroupForTags(const ::std::string& group, const ::Ice::Context& __ctx)
    {
        byGroupForTags(group, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_byGroupForTags(const ::std::string& group)
    {
        return begin_byGroupForTags(group, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byGroupForTags(const ::std::string& group, const ::Ice::Context& __ctx)
    {
        return begin_byGroupForTags(group, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byGroupForTags(const ::std::string& group, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byGroupForTags(group, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byGroupForTags(const ::std::string& group, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byGroupForTags(group, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byGroupForTags(const ::std::string& group, const ::omero::api::Callback_Search_byGroupForTagsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byGroupForTags(group, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byGroupForTags(const ::std::string& group, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_byGroupForTagsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byGroupForTags(group, &__ctx, __del, __cookie);
    }

    void end_byGroupForTags(const ::Ice::AsyncResultPtr&);
    
private:

    void byGroupForTags(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_byGroupForTags(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool byGroupForTags_async(const ::omero::api::AMI_Search_byGroupForTagsPtr&, const ::std::string&);
    bool byGroupForTags_async(const ::omero::api::AMI_Search_byGroupForTagsPtr&, const ::std::string&, const ::Ice::Context&);

    void byTagForGroups(const ::std::string& tag)
    {
        byTagForGroups(tag, 0);
    }
    void byTagForGroups(const ::std::string& tag, const ::Ice::Context& __ctx)
    {
        byTagForGroups(tag, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_byTagForGroups(const ::std::string& tag)
    {
        return begin_byTagForGroups(tag, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byTagForGroups(const ::std::string& tag, const ::Ice::Context& __ctx)
    {
        return begin_byTagForGroups(tag, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byTagForGroups(const ::std::string& tag, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byTagForGroups(tag, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byTagForGroups(const ::std::string& tag, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byTagForGroups(tag, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byTagForGroups(const ::std::string& tag, const ::omero::api::Callback_Search_byTagForGroupsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byTagForGroups(tag, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byTagForGroups(const ::std::string& tag, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_byTagForGroupsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byTagForGroups(tag, &__ctx, __del, __cookie);
    }

    void end_byTagForGroups(const ::Ice::AsyncResultPtr&);
    
private:

    void byTagForGroups(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_byTagForGroups(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool byTagForGroups_async(const ::omero::api::AMI_Search_byTagForGroupsPtr&, const ::std::string&);
    bool byTagForGroups_async(const ::omero::api::AMI_Search_byTagForGroupsPtr&, const ::std::string&, const ::Ice::Context&);

    void byFullText(const ::std::string& query)
    {
        byFullText(query, 0);
    }
    void byFullText(const ::std::string& query, const ::Ice::Context& __ctx)
    {
        byFullText(query, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_byFullText(const ::std::string& query)
    {
        return begin_byFullText(query, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byFullText(const ::std::string& query, const ::Ice::Context& __ctx)
    {
        return begin_byFullText(query, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byFullText(const ::std::string& query, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byFullText(query, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byFullText(const ::std::string& query, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byFullText(query, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byFullText(const ::std::string& query, const ::omero::api::Callback_Search_byFullTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byFullText(query, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byFullText(const ::std::string& query, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_byFullTextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byFullText(query, &__ctx, __del, __cookie);
    }

    void end_byFullText(const ::Ice::AsyncResultPtr&);
    
private:

    void byFullText(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_byFullText(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool byFullText_async(const ::omero::api::AMI_Search_byFullTextPtr&, const ::std::string&);
    bool byFullText_async(const ::omero::api::AMI_Search_byFullTextPtr&, const ::std::string&, const ::Ice::Context&);

    void byLuceneQueryBuilder(const ::std::string& fields, const ::std::string& from, const ::std::string& to, const ::std::string& dateType, const ::std::string& query)
    {
        byLuceneQueryBuilder(fields, from, to, dateType, query, 0);
    }
    void byLuceneQueryBuilder(const ::std::string& fields, const ::std::string& from, const ::std::string& to, const ::std::string& dateType, const ::std::string& query, const ::Ice::Context& __ctx)
    {
        byLuceneQueryBuilder(fields, from, to, dateType, query, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_byLuceneQueryBuilder(const ::std::string& fields, const ::std::string& from, const ::std::string& to, const ::std::string& dateType, const ::std::string& query)
    {
        return begin_byLuceneQueryBuilder(fields, from, to, dateType, query, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byLuceneQueryBuilder(const ::std::string& fields, const ::std::string& from, const ::std::string& to, const ::std::string& dateType, const ::std::string& query, const ::Ice::Context& __ctx)
    {
        return begin_byLuceneQueryBuilder(fields, from, to, dateType, query, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byLuceneQueryBuilder(const ::std::string& fields, const ::std::string& from, const ::std::string& to, const ::std::string& dateType, const ::std::string& query, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byLuceneQueryBuilder(fields, from, to, dateType, query, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byLuceneQueryBuilder(const ::std::string& fields, const ::std::string& from, const ::std::string& to, const ::std::string& dateType, const ::std::string& query, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byLuceneQueryBuilder(fields, from, to, dateType, query, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byLuceneQueryBuilder(const ::std::string& fields, const ::std::string& from, const ::std::string& to, const ::std::string& dateType, const ::std::string& query, const ::omero::api::Callback_Search_byLuceneQueryBuilderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byLuceneQueryBuilder(fields, from, to, dateType, query, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byLuceneQueryBuilder(const ::std::string& fields, const ::std::string& from, const ::std::string& to, const ::std::string& dateType, const ::std::string& query, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_byLuceneQueryBuilderPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byLuceneQueryBuilder(fields, from, to, dateType, query, &__ctx, __del, __cookie);
    }

    void end_byLuceneQueryBuilder(const ::Ice::AsyncResultPtr&);
    
private:

    void byLuceneQueryBuilder(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_byLuceneQueryBuilder(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool byLuceneQueryBuilder_async(const ::omero::api::AMI_Search_byLuceneQueryBuilderPtr&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&);
    bool byLuceneQueryBuilder_async(const ::omero::api::AMI_Search_byLuceneQueryBuilderPtr&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);

    void bySimilarTerms(const ::omero::api::StringSet& terms)
    {
        bySimilarTerms(terms, 0);
    }
    void bySimilarTerms(const ::omero::api::StringSet& terms, const ::Ice::Context& __ctx)
    {
        bySimilarTerms(terms, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_bySimilarTerms(const ::omero::api::StringSet& terms)
    {
        return begin_bySimilarTerms(terms, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bySimilarTerms(const ::omero::api::StringSet& terms, const ::Ice::Context& __ctx)
    {
        return begin_bySimilarTerms(terms, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bySimilarTerms(const ::omero::api::StringSet& terms, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bySimilarTerms(terms, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bySimilarTerms(const ::omero::api::StringSet& terms, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bySimilarTerms(terms, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bySimilarTerms(const ::omero::api::StringSet& terms, const ::omero::api::Callback_Search_bySimilarTermsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bySimilarTerms(terms, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bySimilarTerms(const ::omero::api::StringSet& terms, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_bySimilarTermsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bySimilarTerms(terms, &__ctx, __del, __cookie);
    }

    void end_bySimilarTerms(const ::Ice::AsyncResultPtr&);
    
private:

    void bySimilarTerms(const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_bySimilarTerms(const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool bySimilarTerms_async(const ::omero::api::AMI_Search_bySimilarTermsPtr&, const ::omero::api::StringSet&);
    bool bySimilarTerms_async(const ::omero::api::AMI_Search_bySimilarTermsPtr&, const ::omero::api::StringSet&, const ::Ice::Context&);

    void byHqlQuery(const ::std::string& query, const ::omero::sys::ParametersPtr& params)
    {
        byHqlQuery(query, params, 0);
    }
    void byHqlQuery(const ::std::string& query, const ::omero::sys::ParametersPtr& params, const ::Ice::Context& __ctx)
    {
        byHqlQuery(query, params, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_byHqlQuery(const ::std::string& query, const ::omero::sys::ParametersPtr& params)
    {
        return begin_byHqlQuery(query, params, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byHqlQuery(const ::std::string& query, const ::omero::sys::ParametersPtr& params, const ::Ice::Context& __ctx)
    {
        return begin_byHqlQuery(query, params, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byHqlQuery(const ::std::string& query, const ::omero::sys::ParametersPtr& params, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byHqlQuery(query, params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byHqlQuery(const ::std::string& query, const ::omero::sys::ParametersPtr& params, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byHqlQuery(query, params, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byHqlQuery(const ::std::string& query, const ::omero::sys::ParametersPtr& params, const ::omero::api::Callback_Search_byHqlQueryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byHqlQuery(query, params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byHqlQuery(const ::std::string& query, const ::omero::sys::ParametersPtr& params, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_byHqlQueryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byHqlQuery(query, params, &__ctx, __del, __cookie);
    }

    void end_byHqlQuery(const ::Ice::AsyncResultPtr&);
    
private:

    void byHqlQuery(const ::std::string&, const ::omero::sys::ParametersPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_byHqlQuery(const ::std::string&, const ::omero::sys::ParametersPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool byHqlQuery_async(const ::omero::api::AMI_Search_byHqlQueryPtr&, const ::std::string&, const ::omero::sys::ParametersPtr&);
    bool byHqlQuery_async(const ::omero::api::AMI_Search_byHqlQueryPtr&, const ::std::string&, const ::omero::sys::ParametersPtr&, const ::Ice::Context&);

    void bySomeMustNone(const ::omero::api::StringSet& some, const ::omero::api::StringSet& must, const ::omero::api::StringSet& none)
    {
        bySomeMustNone(some, must, none, 0);
    }
    void bySomeMustNone(const ::omero::api::StringSet& some, const ::omero::api::StringSet& must, const ::omero::api::StringSet& none, const ::Ice::Context& __ctx)
    {
        bySomeMustNone(some, must, none, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_bySomeMustNone(const ::omero::api::StringSet& some, const ::omero::api::StringSet& must, const ::omero::api::StringSet& none)
    {
        return begin_bySomeMustNone(some, must, none, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bySomeMustNone(const ::omero::api::StringSet& some, const ::omero::api::StringSet& must, const ::omero::api::StringSet& none, const ::Ice::Context& __ctx)
    {
        return begin_bySomeMustNone(some, must, none, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bySomeMustNone(const ::omero::api::StringSet& some, const ::omero::api::StringSet& must, const ::omero::api::StringSet& none, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bySomeMustNone(some, must, none, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bySomeMustNone(const ::omero::api::StringSet& some, const ::omero::api::StringSet& must, const ::omero::api::StringSet& none, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bySomeMustNone(some, must, none, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bySomeMustNone(const ::omero::api::StringSet& some, const ::omero::api::StringSet& must, const ::omero::api::StringSet& none, const ::omero::api::Callback_Search_bySomeMustNonePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bySomeMustNone(some, must, none, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bySomeMustNone(const ::omero::api::StringSet& some, const ::omero::api::StringSet& must, const ::omero::api::StringSet& none, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_bySomeMustNonePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bySomeMustNone(some, must, none, &__ctx, __del, __cookie);
    }

    void end_bySomeMustNone(const ::Ice::AsyncResultPtr&);
    
private:

    void bySomeMustNone(const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_bySomeMustNone(const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool bySomeMustNone_async(const ::omero::api::AMI_Search_bySomeMustNonePtr&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::omero::api::StringSet&);
    bool bySomeMustNone_async(const ::omero::api::AMI_Search_bySomeMustNonePtr&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::Ice::Context&);

    void byAnnotatedWith(const ::omero::api::AnnotationList& examples)
    {
        byAnnotatedWith(examples, 0);
    }
    void byAnnotatedWith(const ::omero::api::AnnotationList& examples, const ::Ice::Context& __ctx)
    {
        byAnnotatedWith(examples, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_byAnnotatedWith(const ::omero::api::AnnotationList& examples)
    {
        return begin_byAnnotatedWith(examples, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byAnnotatedWith(const ::omero::api::AnnotationList& examples, const ::Ice::Context& __ctx)
    {
        return begin_byAnnotatedWith(examples, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_byAnnotatedWith(const ::omero::api::AnnotationList& examples, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byAnnotatedWith(examples, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byAnnotatedWith(const ::omero::api::AnnotationList& examples, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byAnnotatedWith(examples, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byAnnotatedWith(const ::omero::api::AnnotationList& examples, const ::omero::api::Callback_Search_byAnnotatedWithPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byAnnotatedWith(examples, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_byAnnotatedWith(const ::omero::api::AnnotationList& examples, const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_byAnnotatedWithPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_byAnnotatedWith(examples, &__ctx, __del, __cookie);
    }

    void end_byAnnotatedWith(const ::Ice::AsyncResultPtr&);
    
private:

    void byAnnotatedWith(const ::omero::api::AnnotationList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_byAnnotatedWith(const ::omero::api::AnnotationList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool byAnnotatedWith_async(const ::omero::api::AMI_Search_byAnnotatedWithPtr&, const ::omero::api::AnnotationList&);
    bool byAnnotatedWith_async(const ::omero::api::AMI_Search_byAnnotatedWithPtr&, const ::omero::api::AnnotationList&, const ::Ice::Context&);

    void clearQueries()
    {
        clearQueries(0);
    }
    void clearQueries(const ::Ice::Context& __ctx)
    {
        clearQueries(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_clearQueries()
    {
        return begin_clearQueries(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearQueries(const ::Ice::Context& __ctx)
    {
        return begin_clearQueries(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearQueries(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearQueries(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearQueries(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearQueries(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearQueries(const ::omero::api::Callback_Search_clearQueriesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearQueries(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearQueries(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_clearQueriesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearQueries(&__ctx, __del, __cookie);
    }

    void end_clearQueries(const ::Ice::AsyncResultPtr&);
    
private:

    void clearQueries(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clearQueries(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool clearQueries_async(const ::omero::api::AMI_Search_clearQueriesPtr&);
    bool clearQueries_async(const ::omero::api::AMI_Search_clearQueriesPtr&, const ::Ice::Context&);

    void _cpp_and()
    {
        _cpp_and(0);
    }
    void _cpp_and(const ::Ice::Context& __ctx)
    {
        _cpp_and(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_and()
    {
        return begin_and(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_and(const ::Ice::Context& __ctx)
    {
        return begin_and(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_and(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_and(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_and(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_and(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_and(const ::omero::api::Callback_Search_andPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_and(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_and(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_andPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_and(&__ctx, __del, __cookie);
    }

    void end_and(const ::Ice::AsyncResultPtr&);
    
private:

    void _cpp_and(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_and(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool and_async(const ::omero::api::AMI_Search_andPtr&);
    bool and_async(const ::omero::api::AMI_Search_andPtr&, const ::Ice::Context&);

    void _cpp_or()
    {
        _cpp_or(0);
    }
    void _cpp_or(const ::Ice::Context& __ctx)
    {
        _cpp_or(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_or()
    {
        return begin_or(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_or(const ::Ice::Context& __ctx)
    {
        return begin_or(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_or(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_or(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_or(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_or(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_or(const ::omero::api::Callback_Search_orPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_or(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_or(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_orPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_or(&__ctx, __del, __cookie);
    }

    void end_or(const ::Ice::AsyncResultPtr&);
    
private:

    void _cpp_or(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_or(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool or_async(const ::omero::api::AMI_Search_orPtr&);
    bool or_async(const ::omero::api::AMI_Search_orPtr&, const ::Ice::Context&);

    void _cpp_not()
    {
        _cpp_not(0);
    }
    void _cpp_not(const ::Ice::Context& __ctx)
    {
        _cpp_not(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_not()
    {
        return begin_not(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_not(const ::Ice::Context& __ctx)
    {
        return begin_not(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_not(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_not(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_not(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_not(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_not(const ::omero::api::Callback_Search_notPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_not(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_not(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_notPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_not(&__ctx, __del, __cookie);
    }

    void end_not(const ::Ice::AsyncResultPtr&);
    
private:

    void _cpp_not(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_not(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool not_async(const ::omero::api::AMI_Search_notPtr&);
    bool not_async(const ::omero::api::AMI_Search_notPtr&, const ::Ice::Context&);

    bool hasNext()
    {
        return hasNext(0);
    }
    bool hasNext(const ::Ice::Context& __ctx)
    {
        return hasNext(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_hasNext()
    {
        return begin_hasNext(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hasNext(const ::Ice::Context& __ctx)
    {
        return begin_hasNext(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hasNext(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hasNext(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_hasNext(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hasNext(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_hasNext(const ::omero::api::Callback_Search_hasNextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hasNext(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_hasNext(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_hasNextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hasNext(&__ctx, __del, __cookie);
    }

    bool end_hasNext(const ::Ice::AsyncResultPtr&);
    
private:

    bool hasNext(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_hasNext(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool hasNext_async(const ::omero::api::AMI_Search_hasNextPtr&);
    bool hasNext_async(const ::omero::api::AMI_Search_hasNextPtr&, const ::Ice::Context&);

    ::omero::model::IObjectPtr next()
    {
        return next(0);
    }
    ::omero::model::IObjectPtr next(const ::Ice::Context& __ctx)
    {
        return next(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_next()
    {
        return begin_next(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_next(const ::Ice::Context& __ctx)
    {
        return begin_next(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_next(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_next(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_next(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_next(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_next(const ::omero::api::Callback_Search_nextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_next(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_next(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_nextPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_next(&__ctx, __del, __cookie);
    }

    ::omero::model::IObjectPtr end_next(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::model::IObjectPtr next(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_next(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool next_async(const ::omero::api::AMI_Search_nextPtr&);
    bool next_async(const ::omero::api::AMI_Search_nextPtr&, const ::Ice::Context&);

    ::omero::api::IObjectList results()
    {
        return results(0);
    }
    ::omero::api::IObjectList results(const ::Ice::Context& __ctx)
    {
        return results(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_results()
    {
        return begin_results(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_results(const ::Ice::Context& __ctx)
    {
        return begin_results(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_results(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_results(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_results(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_results(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_results(const ::omero::api::Callback_Search_resultsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_results(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_results(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_resultsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_results(&__ctx, __del, __cookie);
    }

    ::omero::api::IObjectList end_results(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::IObjectList results(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_results(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool results_async(const ::omero::api::AMI_Search_resultsPtr&);
    bool results_async(const ::omero::api::AMI_Search_resultsPtr&, const ::Ice::Context&);

    ::omero::api::SearchMetadata currentMetadata()
    {
        return currentMetadata(0);
    }
    ::omero::api::SearchMetadata currentMetadata(const ::Ice::Context& __ctx)
    {
        return currentMetadata(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_currentMetadata()
    {
        return begin_currentMetadata(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_currentMetadata(const ::Ice::Context& __ctx)
    {
        return begin_currentMetadata(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_currentMetadata(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_currentMetadata(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_currentMetadata(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_currentMetadata(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_currentMetadata(const ::omero::api::Callback_Search_currentMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_currentMetadata(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_currentMetadata(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_currentMetadataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_currentMetadata(&__ctx, __del, __cookie);
    }

    ::omero::api::SearchMetadata end_currentMetadata(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::SearchMetadata currentMetadata(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_currentMetadata(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool currentMetadata_async(const ::omero::api::AMI_Search_currentMetadataPtr&);
    bool currentMetadata_async(const ::omero::api::AMI_Search_currentMetadataPtr&, const ::Ice::Context&);

    ::omero::api::SearchMetadataList currentMetadataList()
    {
        return currentMetadataList(0);
    }
    ::omero::api::SearchMetadataList currentMetadataList(const ::Ice::Context& __ctx)
    {
        return currentMetadataList(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_currentMetadataList()
    {
        return begin_currentMetadataList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_currentMetadataList(const ::Ice::Context& __ctx)
    {
        return begin_currentMetadataList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_currentMetadataList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_currentMetadataList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_currentMetadataList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_currentMetadataList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_currentMetadataList(const ::omero::api::Callback_Search_currentMetadataListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_currentMetadataList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_currentMetadataList(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_currentMetadataListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_currentMetadataList(&__ctx, __del, __cookie);
    }

    ::omero::api::SearchMetadataList end_currentMetadataList(const ::Ice::AsyncResultPtr&);
    
private:

    ::omero::api::SearchMetadataList currentMetadataList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_currentMetadataList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool currentMetadataList_async(const ::omero::api::AMI_Search_currentMetadataListPtr&);
    bool currentMetadataList_async(const ::omero::api::AMI_Search_currentMetadataListPtr&, const ::Ice::Context&);

    void remove()
    {
        remove(0);
    }
    void remove(const ::Ice::Context& __ctx)
    {
        remove(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_remove()
    {
        return begin_remove(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::Ice::Context& __ctx)
    {
        return begin_remove(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::omero::api::Callback_Search_removePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::Ice::Context& __ctx, const ::omero::api::Callback_Search_removePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(&__ctx, __del, __cookie);
    }

    void end_remove(const ::Ice::AsyncResultPtr&);
    
private:

    void remove(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_remove(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool remove_async(const ::omero::api::AMI_Search_removePtr&);
    bool remove_async(const ::omero::api::AMI_Search_removePtr&, const ::Ice::Context&);
    
    ::IceInternal::ProxyHandle<Search> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Search> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Search*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Search*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

}

namespace IceDelegate
{

namespace omero
{

namespace api
{

class Search : virtual public ::IceDelegate::omero::api::StatefulServiceInterface
{
public:

    virtual ::Ice::Int activeQueries(const ::Ice::Context*) = 0;

    virtual void setBatchSize(::Ice::Int, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getBatchSize(const ::Ice::Context*) = 0;

    virtual void setMergedBatches(bool, const ::Ice::Context*) = 0;

    virtual bool isMergedBatches(const ::Ice::Context*) = 0;

    virtual void setCaseSentivice(bool, const ::Ice::Context*) = 0;

    virtual bool isCaseSensitive(const ::Ice::Context*) = 0;

    virtual void setUseProjections(bool, const ::Ice::Context*) = 0;

    virtual bool isUseProjections(const ::Ice::Context*) = 0;

    virtual void setReturnUnloaded(bool, const ::Ice::Context*) = 0;

    virtual bool isReturnUnloaded(const ::Ice::Context*) = 0;

    virtual void setAllowLeadingWildcard(bool, const ::Ice::Context*) = 0;

    virtual bool isAllowLeadingWildcard(const ::Ice::Context*) = 0;

    virtual void onlyType(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void onlyTypes(const ::omero::api::StringSet&, const ::Ice::Context*) = 0;

    virtual void allTypes(const ::Ice::Context*) = 0;

    virtual void onlyIds(const ::omero::sys::LongList&, const ::Ice::Context*) = 0;

    virtual void onlyOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*) = 0;

    virtual void notOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*) = 0;

    virtual void onlyCreatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*) = 0;

    virtual void onlyModifiedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*) = 0;

    virtual void onlyAnnotatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*) = 0;

    virtual void onlyAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*) = 0;

    virtual void notAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*) = 0;

    virtual void onlyAnnotatedWith(const ::omero::api::StringSet&, const ::Ice::Context*) = 0;

    virtual void addOrderByAsc(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void addOrderByDesc(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void unordered(const ::Ice::Context*) = 0;

    virtual void fetchAnnotations(const ::omero::api::StringSet&, const ::Ice::Context*) = 0;

    virtual void fetchAlso(const ::omero::api::StringSet&, const ::Ice::Context*) = 0;

    virtual void resetDefaults(const ::Ice::Context*) = 0;

    virtual void byGroupForTags(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void byTagForGroups(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void byFullText(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void byLuceneQueryBuilder(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void bySimilarTerms(const ::omero::api::StringSet&, const ::Ice::Context*) = 0;

    virtual void byHqlQuery(const ::std::string&, const ::omero::sys::ParametersPtr&, const ::Ice::Context*) = 0;

    virtual void bySomeMustNone(const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::Ice::Context*) = 0;

    virtual void byAnnotatedWith(const ::omero::api::AnnotationList&, const ::Ice::Context*) = 0;

    virtual void clearQueries(const ::Ice::Context*) = 0;

    virtual void _cpp_and(const ::Ice::Context*) = 0;

    virtual void _cpp_or(const ::Ice::Context*) = 0;

    virtual void _cpp_not(const ::Ice::Context*) = 0;

    virtual bool hasNext(const ::Ice::Context*) = 0;

    virtual ::omero::model::IObjectPtr next(const ::Ice::Context*) = 0;

    virtual ::omero::api::IObjectList results(const ::Ice::Context*) = 0;

    virtual ::omero::api::SearchMetadata currentMetadata(const ::Ice::Context*) = 0;

    virtual ::omero::api::SearchMetadataList currentMetadataList(const ::Ice::Context*) = 0;

    virtual void remove(const ::Ice::Context*) = 0;
};

}

}

}

namespace IceDelegateM
{

namespace omero
{

namespace api
{

class Search : virtual public ::IceDelegate::omero::api::Search,
               virtual public ::IceDelegateM::omero::api::StatefulServiceInterface
{
public:

    virtual ::Ice::Int activeQueries(const ::Ice::Context*);

    virtual void setBatchSize(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getBatchSize(const ::Ice::Context*);

    virtual void setMergedBatches(bool, const ::Ice::Context*);

    virtual bool isMergedBatches(const ::Ice::Context*);

    virtual void setCaseSentivice(bool, const ::Ice::Context*);

    virtual bool isCaseSensitive(const ::Ice::Context*);

    virtual void setUseProjections(bool, const ::Ice::Context*);

    virtual bool isUseProjections(const ::Ice::Context*);

    virtual void setReturnUnloaded(bool, const ::Ice::Context*);

    virtual bool isReturnUnloaded(const ::Ice::Context*);

    virtual void setAllowLeadingWildcard(bool, const ::Ice::Context*);

    virtual bool isAllowLeadingWildcard(const ::Ice::Context*);

    virtual void onlyType(const ::std::string&, const ::Ice::Context*);

    virtual void onlyTypes(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void allTypes(const ::Ice::Context*);

    virtual void onlyIds(const ::omero::sys::LongList&, const ::Ice::Context*);

    virtual void onlyOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);

    virtual void notOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);

    virtual void onlyCreatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*);

    virtual void onlyModifiedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*);

    virtual void onlyAnnotatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*);

    virtual void onlyAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);

    virtual void notAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);

    virtual void onlyAnnotatedWith(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void addOrderByAsc(const ::std::string&, const ::Ice::Context*);

    virtual void addOrderByDesc(const ::std::string&, const ::Ice::Context*);

    virtual void unordered(const ::Ice::Context*);

    virtual void fetchAnnotations(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void fetchAlso(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void resetDefaults(const ::Ice::Context*);

    virtual void byGroupForTags(const ::std::string&, const ::Ice::Context*);

    virtual void byTagForGroups(const ::std::string&, const ::Ice::Context*);

    virtual void byFullText(const ::std::string&, const ::Ice::Context*);

    virtual void byLuceneQueryBuilder(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void bySimilarTerms(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void byHqlQuery(const ::std::string&, const ::omero::sys::ParametersPtr&, const ::Ice::Context*);

    virtual void bySomeMustNone(const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void byAnnotatedWith(const ::omero::api::AnnotationList&, const ::Ice::Context*);

    virtual void clearQueries(const ::Ice::Context*);

    virtual void _cpp_and(const ::Ice::Context*);

    virtual void _cpp_or(const ::Ice::Context*);

    virtual void _cpp_not(const ::Ice::Context*);

    virtual bool hasNext(const ::Ice::Context*);

    virtual ::omero::model::IObjectPtr next(const ::Ice::Context*);

    virtual ::omero::api::IObjectList results(const ::Ice::Context*);

    virtual ::omero::api::SearchMetadata currentMetadata(const ::Ice::Context*);

    virtual ::omero::api::SearchMetadataList currentMetadataList(const ::Ice::Context*);

    virtual void remove(const ::Ice::Context*);
};

}

}

}

namespace IceDelegateD
{

namespace omero
{

namespace api
{

class Search : virtual public ::IceDelegate::omero::api::Search,
               virtual public ::IceDelegateD::omero::api::StatefulServiceInterface
{
public:

    virtual ::Ice::Int activeQueries(const ::Ice::Context*);

    virtual void setBatchSize(::Ice::Int, const ::Ice::Context*);

    virtual ::Ice::Int getBatchSize(const ::Ice::Context*);

    virtual void setMergedBatches(bool, const ::Ice::Context*);

    virtual bool isMergedBatches(const ::Ice::Context*);

    virtual void setCaseSentivice(bool, const ::Ice::Context*);

    virtual bool isCaseSensitive(const ::Ice::Context*);

    virtual void setUseProjections(bool, const ::Ice::Context*);

    virtual bool isUseProjections(const ::Ice::Context*);

    virtual void setReturnUnloaded(bool, const ::Ice::Context*);

    virtual bool isReturnUnloaded(const ::Ice::Context*);

    virtual void setAllowLeadingWildcard(bool, const ::Ice::Context*);

    virtual bool isAllowLeadingWildcard(const ::Ice::Context*);

    virtual void onlyType(const ::std::string&, const ::Ice::Context*);

    virtual void onlyTypes(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void allTypes(const ::Ice::Context*);

    virtual void onlyIds(const ::omero::sys::LongList&, const ::Ice::Context*);

    virtual void onlyOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);

    virtual void notOwnedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);

    virtual void onlyCreatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*);

    virtual void onlyModifiedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*);

    virtual void onlyAnnotatedBetween(const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Context*);

    virtual void onlyAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);

    virtual void notAnnotatedBy(const ::omero::model::DetailsPtr&, const ::Ice::Context*);

    virtual void onlyAnnotatedWith(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void addOrderByAsc(const ::std::string&, const ::Ice::Context*);

    virtual void addOrderByDesc(const ::std::string&, const ::Ice::Context*);

    virtual void unordered(const ::Ice::Context*);

    virtual void fetchAnnotations(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void fetchAlso(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void resetDefaults(const ::Ice::Context*);

    virtual void byGroupForTags(const ::std::string&, const ::Ice::Context*);

    virtual void byTagForGroups(const ::std::string&, const ::Ice::Context*);

    virtual void byFullText(const ::std::string&, const ::Ice::Context*);

    virtual void byLuceneQueryBuilder(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void bySimilarTerms(const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void byHqlQuery(const ::std::string&, const ::omero::sys::ParametersPtr&, const ::Ice::Context*);

    virtual void bySomeMustNone(const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::Ice::Context*);

    virtual void byAnnotatedWith(const ::omero::api::AnnotationList&, const ::Ice::Context*);

    virtual void clearQueries(const ::Ice::Context*);

    virtual void _cpp_and(const ::Ice::Context*);

    virtual void _cpp_or(const ::Ice::Context*);

    virtual void _cpp_not(const ::Ice::Context*);

    virtual bool hasNext(const ::Ice::Context*);

    virtual ::omero::model::IObjectPtr next(const ::Ice::Context*);

    virtual ::omero::api::IObjectList results(const ::Ice::Context*);

    virtual ::omero::api::SearchMetadata currentMetadata(const ::Ice::Context*);

    virtual ::omero::api::SearchMetadataList currentMetadataList(const ::Ice::Context*);

    virtual void remove(const ::Ice::Context*);
};

}

}

}

namespace omero
{

namespace api
{

class Search : virtual public ::omero::api::StatefulServiceInterface
{
public:

    typedef SearchPrx ProxyType;
    typedef SearchPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void activeQueries_async(const ::omero::api::AMD_Search_activeQueriesPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___activeQueries(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setBatchSize_async(const ::omero::api::AMD_Search_setBatchSizePtr&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setBatchSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getBatchSize_async(const ::omero::api::AMD_Search_getBatchSizePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getBatchSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setMergedBatches_async(const ::omero::api::AMD_Search_setMergedBatchesPtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setMergedBatches(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void isMergedBatches_async(const ::omero::api::AMD_Search_isMergedBatchesPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isMergedBatches(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setCaseSentivice_async(const ::omero::api::AMD_Search_setCaseSentivicePtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setCaseSentivice(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void isCaseSensitive_async(const ::omero::api::AMD_Search_isCaseSensitivePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isCaseSensitive(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setUseProjections_async(const ::omero::api::AMD_Search_setUseProjectionsPtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setUseProjections(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void isUseProjections_async(const ::omero::api::AMD_Search_isUseProjectionsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isUseProjections(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setReturnUnloaded_async(const ::omero::api::AMD_Search_setReturnUnloadedPtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setReturnUnloaded(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void isReturnUnloaded_async(const ::omero::api::AMD_Search_isReturnUnloadedPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isReturnUnloaded(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setAllowLeadingWildcard_async(const ::omero::api::AMD_Search_setAllowLeadingWildcardPtr&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setAllowLeadingWildcard(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void isAllowLeadingWildcard_async(const ::omero::api::AMD_Search_isAllowLeadingWildcardPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isAllowLeadingWildcard(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void onlyType_async(const ::omero::api::AMD_Search_onlyTypePtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onlyType(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void onlyTypes_async(const ::omero::api::AMD_Search_onlyTypesPtr&, const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onlyTypes(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void allTypes_async(const ::omero::api::AMD_Search_allTypesPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___allTypes(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void onlyIds_async(const ::omero::api::AMD_Search_onlyIdsPtr&, const ::omero::sys::LongList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onlyIds(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void onlyOwnedBy_async(const ::omero::api::AMD_Search_onlyOwnedByPtr&, const ::omero::model::DetailsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onlyOwnedBy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void notOwnedBy_async(const ::omero::api::AMD_Search_notOwnedByPtr&, const ::omero::model::DetailsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___notOwnedBy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void onlyCreatedBetween_async(const ::omero::api::AMD_Search_onlyCreatedBetweenPtr&, const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onlyCreatedBetween(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void onlyModifiedBetween_async(const ::omero::api::AMD_Search_onlyModifiedBetweenPtr&, const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onlyModifiedBetween(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void onlyAnnotatedBetween_async(const ::omero::api::AMD_Search_onlyAnnotatedBetweenPtr&, const ::omero::RTimePtr&, const ::omero::RTimePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onlyAnnotatedBetween(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void onlyAnnotatedBy_async(const ::omero::api::AMD_Search_onlyAnnotatedByPtr&, const ::omero::model::DetailsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onlyAnnotatedBy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void notAnnotatedBy_async(const ::omero::api::AMD_Search_notAnnotatedByPtr&, const ::omero::model::DetailsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___notAnnotatedBy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void onlyAnnotatedWith_async(const ::omero::api::AMD_Search_onlyAnnotatedWithPtr&, const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___onlyAnnotatedWith(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addOrderByAsc_async(const ::omero::api::AMD_Search_addOrderByAscPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addOrderByAsc(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addOrderByDesc_async(const ::omero::api::AMD_Search_addOrderByDescPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addOrderByDesc(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unordered_async(const ::omero::api::AMD_Search_unorderedPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unordered(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void fetchAnnotations_async(const ::omero::api::AMD_Search_fetchAnnotationsPtr&, const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fetchAnnotations(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void fetchAlso_async(const ::omero::api::AMD_Search_fetchAlsoPtr&, const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fetchAlso(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void resetDefaults_async(const ::omero::api::AMD_Search_resetDefaultsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___resetDefaults(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void byGroupForTags_async(const ::omero::api::AMD_Search_byGroupForTagsPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___byGroupForTags(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void byTagForGroups_async(const ::omero::api::AMD_Search_byTagForGroupsPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___byTagForGroups(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void byFullText_async(const ::omero::api::AMD_Search_byFullTextPtr&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___byFullText(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void byLuceneQueryBuilder_async(const ::omero::api::AMD_Search_byLuceneQueryBuilderPtr&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___byLuceneQueryBuilder(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void bySimilarTerms_async(const ::omero::api::AMD_Search_bySimilarTermsPtr&, const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___bySimilarTerms(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void byHqlQuery_async(const ::omero::api::AMD_Search_byHqlQueryPtr&, const ::std::string&, const ::omero::sys::ParametersPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___byHqlQuery(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void bySomeMustNone_async(const ::omero::api::AMD_Search_bySomeMustNonePtr&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::omero::api::StringSet&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___bySomeMustNone(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void byAnnotatedWith_async(const ::omero::api::AMD_Search_byAnnotatedWithPtr&, const ::omero::api::AnnotationList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___byAnnotatedWith(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clearQueries_async(const ::omero::api::AMD_Search_clearQueriesPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clearQueries(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void and_async(const ::omero::api::AMD_Search_andPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___and(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void or_async(const ::omero::api::AMD_Search_orPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___or(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void not_async(const ::omero::api::AMD_Search_notPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___not(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void hasNext_async(const ::omero::api::AMD_Search_hasNextPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___hasNext(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void next_async(const ::omero::api::AMD_Search_nextPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___next(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void results_async(const ::omero::api::AMD_Search_resultsPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___results(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void currentMetadata_async(const ::omero::api::AMD_Search_currentMetadataPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___currentMetadata(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void currentMetadataList_async(const ::omero::api::AMD_Search_currentMetadataListPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___currentMetadataList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void remove_async(const ::omero::api::AMD_Search_removePtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___remove(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const Search& l, const Search& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Search& l, const Search& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

}

namespace omero
{

namespace api
{

template<class T>
class CallbackNC_Search_activeQueries : public Callback_Search_activeQueries_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Search_activeQueries(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_activeQueries(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_activeQueriesPtr
newCallback_Search_activeQueries(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_activeQueries<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_activeQueriesPtr
newCallback_Search_activeQueries(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_activeQueries<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_activeQueries : public Callback_Search_activeQueries_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Search_activeQueries(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_activeQueries(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_activeQueriesPtr
newCallback_Search_activeQueries(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_activeQueries<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_activeQueriesPtr
newCallback_Search_activeQueries(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_activeQueries<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_setBatchSize : public Callback_Search_setBatchSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_setBatchSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setBatchSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_setBatchSizePtr
newCallback_Search_setBatchSize(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setBatchSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setBatchSizePtr
newCallback_Search_setBatchSize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setBatchSize<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_setBatchSizePtr
newCallback_Search_setBatchSize(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setBatchSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setBatchSizePtr
newCallback_Search_setBatchSize(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setBatchSize<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_setBatchSize : public Callback_Search_setBatchSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_setBatchSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setBatchSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_setBatchSizePtr
newCallback_Search_setBatchSize(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setBatchSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setBatchSizePtr
newCallback_Search_setBatchSize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setBatchSize<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setBatchSizePtr
newCallback_Search_setBatchSize(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setBatchSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setBatchSizePtr
newCallback_Search_setBatchSize(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setBatchSize<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_getBatchSize : public Callback_Search_getBatchSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Search_getBatchSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getBatchSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_getBatchSizePtr
newCallback_Search_getBatchSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_getBatchSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_getBatchSizePtr
newCallback_Search_getBatchSize(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_getBatchSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_getBatchSize : public Callback_Search_getBatchSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Search_getBatchSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getBatchSize(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_getBatchSizePtr
newCallback_Search_getBatchSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_getBatchSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_getBatchSizePtr
newCallback_Search_getBatchSize(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_getBatchSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_setMergedBatches : public Callback_Search_setMergedBatches_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_setMergedBatches(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setMergedBatches(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_setMergedBatchesPtr
newCallback_Search_setMergedBatches(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setMergedBatches<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setMergedBatchesPtr
newCallback_Search_setMergedBatches(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setMergedBatches<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_setMergedBatchesPtr
newCallback_Search_setMergedBatches(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setMergedBatches<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setMergedBatchesPtr
newCallback_Search_setMergedBatches(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setMergedBatches<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_setMergedBatches : public Callback_Search_setMergedBatches_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_setMergedBatches(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setMergedBatches(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_setMergedBatchesPtr
newCallback_Search_setMergedBatches(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setMergedBatches<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setMergedBatchesPtr
newCallback_Search_setMergedBatches(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setMergedBatches<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setMergedBatchesPtr
newCallback_Search_setMergedBatches(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setMergedBatches<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setMergedBatchesPtr
newCallback_Search_setMergedBatches(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setMergedBatches<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_isMergedBatches : public Callback_Search_isMergedBatches_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Search_isMergedBatches(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isMergedBatches(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_isMergedBatchesPtr
newCallback_Search_isMergedBatches(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isMergedBatches<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_isMergedBatchesPtr
newCallback_Search_isMergedBatches(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isMergedBatches<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_isMergedBatches : public Callback_Search_isMergedBatches_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Search_isMergedBatches(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isMergedBatches(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_isMergedBatchesPtr
newCallback_Search_isMergedBatches(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isMergedBatches<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_isMergedBatchesPtr
newCallback_Search_isMergedBatches(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isMergedBatches<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_setCaseSentivice : public Callback_Search_setCaseSentivice_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_setCaseSentivice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setCaseSentivice(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_setCaseSentivicePtr
newCallback_Search_setCaseSentivice(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setCaseSentivice<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setCaseSentivicePtr
newCallback_Search_setCaseSentivice(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setCaseSentivice<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_setCaseSentivicePtr
newCallback_Search_setCaseSentivice(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setCaseSentivice<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setCaseSentivicePtr
newCallback_Search_setCaseSentivice(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setCaseSentivice<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_setCaseSentivice : public Callback_Search_setCaseSentivice_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_setCaseSentivice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setCaseSentivice(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_setCaseSentivicePtr
newCallback_Search_setCaseSentivice(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setCaseSentivice<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setCaseSentivicePtr
newCallback_Search_setCaseSentivice(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setCaseSentivice<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setCaseSentivicePtr
newCallback_Search_setCaseSentivice(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setCaseSentivice<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setCaseSentivicePtr
newCallback_Search_setCaseSentivice(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setCaseSentivice<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_isCaseSensitive : public Callback_Search_isCaseSensitive_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Search_isCaseSensitive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isCaseSensitive(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_isCaseSensitivePtr
newCallback_Search_isCaseSensitive(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isCaseSensitive<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_isCaseSensitivePtr
newCallback_Search_isCaseSensitive(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isCaseSensitive<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_isCaseSensitive : public Callback_Search_isCaseSensitive_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Search_isCaseSensitive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isCaseSensitive(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_isCaseSensitivePtr
newCallback_Search_isCaseSensitive(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isCaseSensitive<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_isCaseSensitivePtr
newCallback_Search_isCaseSensitive(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isCaseSensitive<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_setUseProjections : public Callback_Search_setUseProjections_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_setUseProjections(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setUseProjections(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_setUseProjectionsPtr
newCallback_Search_setUseProjections(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setUseProjections<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setUseProjectionsPtr
newCallback_Search_setUseProjections(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setUseProjections<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_setUseProjectionsPtr
newCallback_Search_setUseProjections(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setUseProjections<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setUseProjectionsPtr
newCallback_Search_setUseProjections(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setUseProjections<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_setUseProjections : public Callback_Search_setUseProjections_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_setUseProjections(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setUseProjections(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_setUseProjectionsPtr
newCallback_Search_setUseProjections(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setUseProjections<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setUseProjectionsPtr
newCallback_Search_setUseProjections(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setUseProjections<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setUseProjectionsPtr
newCallback_Search_setUseProjections(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setUseProjections<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setUseProjectionsPtr
newCallback_Search_setUseProjections(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setUseProjections<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_isUseProjections : public Callback_Search_isUseProjections_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Search_isUseProjections(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isUseProjections(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_isUseProjectionsPtr
newCallback_Search_isUseProjections(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isUseProjections<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_isUseProjectionsPtr
newCallback_Search_isUseProjections(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isUseProjections<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_isUseProjections : public Callback_Search_isUseProjections_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Search_isUseProjections(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isUseProjections(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_isUseProjectionsPtr
newCallback_Search_isUseProjections(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isUseProjections<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_isUseProjectionsPtr
newCallback_Search_isUseProjections(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isUseProjections<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_setReturnUnloaded : public Callback_Search_setReturnUnloaded_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_setReturnUnloaded(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setReturnUnloaded(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_setReturnUnloadedPtr
newCallback_Search_setReturnUnloaded(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setReturnUnloaded<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setReturnUnloadedPtr
newCallback_Search_setReturnUnloaded(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setReturnUnloaded<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_setReturnUnloadedPtr
newCallback_Search_setReturnUnloaded(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setReturnUnloaded<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setReturnUnloadedPtr
newCallback_Search_setReturnUnloaded(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setReturnUnloaded<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_setReturnUnloaded : public Callback_Search_setReturnUnloaded_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_setReturnUnloaded(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setReturnUnloaded(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_setReturnUnloadedPtr
newCallback_Search_setReturnUnloaded(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setReturnUnloaded<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setReturnUnloadedPtr
newCallback_Search_setReturnUnloaded(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setReturnUnloaded<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setReturnUnloadedPtr
newCallback_Search_setReturnUnloaded(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setReturnUnloaded<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setReturnUnloadedPtr
newCallback_Search_setReturnUnloaded(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setReturnUnloaded<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_isReturnUnloaded : public Callback_Search_isReturnUnloaded_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Search_isReturnUnloaded(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isReturnUnloaded(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_isReturnUnloadedPtr
newCallback_Search_isReturnUnloaded(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isReturnUnloaded<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_isReturnUnloadedPtr
newCallback_Search_isReturnUnloaded(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isReturnUnloaded<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_isReturnUnloaded : public Callback_Search_isReturnUnloaded_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Search_isReturnUnloaded(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isReturnUnloaded(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_isReturnUnloadedPtr
newCallback_Search_isReturnUnloaded(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isReturnUnloaded<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_isReturnUnloadedPtr
newCallback_Search_isReturnUnloaded(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isReturnUnloaded<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_setAllowLeadingWildcard : public Callback_Search_setAllowLeadingWildcard_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_setAllowLeadingWildcard(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setAllowLeadingWildcard(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_setAllowLeadingWildcardPtr
newCallback_Search_setAllowLeadingWildcard(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setAllowLeadingWildcard<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setAllowLeadingWildcardPtr
newCallback_Search_setAllowLeadingWildcard(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setAllowLeadingWildcard<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_setAllowLeadingWildcardPtr
newCallback_Search_setAllowLeadingWildcard(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setAllowLeadingWildcard<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_setAllowLeadingWildcardPtr
newCallback_Search_setAllowLeadingWildcard(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_setAllowLeadingWildcard<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_setAllowLeadingWildcard : public Callback_Search_setAllowLeadingWildcard_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_setAllowLeadingWildcard(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setAllowLeadingWildcard(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_setAllowLeadingWildcardPtr
newCallback_Search_setAllowLeadingWildcard(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setAllowLeadingWildcard<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setAllowLeadingWildcardPtr
newCallback_Search_setAllowLeadingWildcard(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setAllowLeadingWildcard<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setAllowLeadingWildcardPtr
newCallback_Search_setAllowLeadingWildcard(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setAllowLeadingWildcard<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_setAllowLeadingWildcardPtr
newCallback_Search_setAllowLeadingWildcard(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_setAllowLeadingWildcard<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_isAllowLeadingWildcard : public Callback_Search_isAllowLeadingWildcard_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Search_isAllowLeadingWildcard(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isAllowLeadingWildcard(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_isAllowLeadingWildcardPtr
newCallback_Search_isAllowLeadingWildcard(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isAllowLeadingWildcard<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_isAllowLeadingWildcardPtr
newCallback_Search_isAllowLeadingWildcard(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_isAllowLeadingWildcard<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_isAllowLeadingWildcard : public Callback_Search_isAllowLeadingWildcard_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Search_isAllowLeadingWildcard(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isAllowLeadingWildcard(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_isAllowLeadingWildcardPtr
newCallback_Search_isAllowLeadingWildcard(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isAllowLeadingWildcard<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_isAllowLeadingWildcardPtr
newCallback_Search_isAllowLeadingWildcard(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_isAllowLeadingWildcard<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_onlyType : public Callback_Search_onlyType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_onlyType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyType(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_onlyTypePtr
newCallback_Search_onlyType(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyType<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyTypePtr
newCallback_Search_onlyType(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyType<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_onlyTypePtr
newCallback_Search_onlyType(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyType<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyTypePtr
newCallback_Search_onlyType(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyType<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_onlyType : public Callback_Search_onlyType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_onlyType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyType(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_onlyTypePtr
newCallback_Search_onlyType(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyType<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyTypePtr
newCallback_Search_onlyType(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyType<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyTypePtr
newCallback_Search_onlyType(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyType<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyTypePtr
newCallback_Search_onlyType(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyType<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_onlyTypes : public Callback_Search_onlyTypes_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_onlyTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyTypes(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_onlyTypesPtr
newCallback_Search_onlyTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyTypes<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyTypesPtr
newCallback_Search_onlyTypes(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyTypes<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_onlyTypesPtr
newCallback_Search_onlyTypes(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyTypes<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyTypesPtr
newCallback_Search_onlyTypes(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyTypes<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_onlyTypes : public Callback_Search_onlyTypes_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_onlyTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyTypes(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_onlyTypesPtr
newCallback_Search_onlyTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyTypes<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyTypesPtr
newCallback_Search_onlyTypes(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyTypes<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyTypesPtr
newCallback_Search_onlyTypes(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyTypes<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyTypesPtr
newCallback_Search_onlyTypes(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyTypes<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_allTypes : public Callback_Search_allTypes_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_allTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_allTypes(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_allTypesPtr
newCallback_Search_allTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_allTypes<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_allTypesPtr
newCallback_Search_allTypes(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_allTypes<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_allTypesPtr
newCallback_Search_allTypes(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_allTypes<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_allTypesPtr
newCallback_Search_allTypes(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_allTypes<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_allTypes : public Callback_Search_allTypes_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_allTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_allTypes(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_allTypesPtr
newCallback_Search_allTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_allTypes<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_allTypesPtr
newCallback_Search_allTypes(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_allTypes<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_allTypesPtr
newCallback_Search_allTypes(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_allTypes<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_allTypesPtr
newCallback_Search_allTypes(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_allTypes<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_onlyIds : public Callback_Search_onlyIds_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_onlyIds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyIds(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_onlyIdsPtr
newCallback_Search_onlyIds(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyIds<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyIdsPtr
newCallback_Search_onlyIds(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyIds<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_onlyIdsPtr
newCallback_Search_onlyIds(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyIds<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyIdsPtr
newCallback_Search_onlyIds(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyIds<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_onlyIds : public Callback_Search_onlyIds_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_onlyIds(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyIds(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_onlyIdsPtr
newCallback_Search_onlyIds(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyIds<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyIdsPtr
newCallback_Search_onlyIds(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyIds<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyIdsPtr
newCallback_Search_onlyIds(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyIds<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyIdsPtr
newCallback_Search_onlyIds(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyIds<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_onlyOwnedBy : public Callback_Search_onlyOwnedBy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_onlyOwnedBy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyOwnedBy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_onlyOwnedByPtr
newCallback_Search_onlyOwnedBy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyOwnedBy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyOwnedByPtr
newCallback_Search_onlyOwnedBy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyOwnedBy<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_onlyOwnedByPtr
newCallback_Search_onlyOwnedBy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyOwnedBy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyOwnedByPtr
newCallback_Search_onlyOwnedBy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyOwnedBy<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_onlyOwnedBy : public Callback_Search_onlyOwnedBy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_onlyOwnedBy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyOwnedBy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_onlyOwnedByPtr
newCallback_Search_onlyOwnedBy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyOwnedBy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyOwnedByPtr
newCallback_Search_onlyOwnedBy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyOwnedBy<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyOwnedByPtr
newCallback_Search_onlyOwnedBy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyOwnedBy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyOwnedByPtr
newCallback_Search_onlyOwnedBy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyOwnedBy<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_notOwnedBy : public Callback_Search_notOwnedBy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_notOwnedBy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_notOwnedBy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_notOwnedByPtr
newCallback_Search_notOwnedBy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_notOwnedBy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_notOwnedByPtr
newCallback_Search_notOwnedBy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_notOwnedBy<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_notOwnedByPtr
newCallback_Search_notOwnedBy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_notOwnedBy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_notOwnedByPtr
newCallback_Search_notOwnedBy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_notOwnedBy<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_notOwnedBy : public Callback_Search_notOwnedBy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_notOwnedBy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_notOwnedBy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_notOwnedByPtr
newCallback_Search_notOwnedBy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_notOwnedBy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_notOwnedByPtr
newCallback_Search_notOwnedBy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_notOwnedBy<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_notOwnedByPtr
newCallback_Search_notOwnedBy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_notOwnedBy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_notOwnedByPtr
newCallback_Search_notOwnedBy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_notOwnedBy<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_onlyCreatedBetween : public Callback_Search_onlyCreatedBetween_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_onlyCreatedBetween(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyCreatedBetween(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_onlyCreatedBetweenPtr
newCallback_Search_onlyCreatedBetween(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyCreatedBetween<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyCreatedBetweenPtr
newCallback_Search_onlyCreatedBetween(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyCreatedBetween<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_onlyCreatedBetweenPtr
newCallback_Search_onlyCreatedBetween(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyCreatedBetween<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyCreatedBetweenPtr
newCallback_Search_onlyCreatedBetween(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyCreatedBetween<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_onlyCreatedBetween : public Callback_Search_onlyCreatedBetween_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_onlyCreatedBetween(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyCreatedBetween(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_onlyCreatedBetweenPtr
newCallback_Search_onlyCreatedBetween(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyCreatedBetween<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyCreatedBetweenPtr
newCallback_Search_onlyCreatedBetween(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyCreatedBetween<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyCreatedBetweenPtr
newCallback_Search_onlyCreatedBetween(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyCreatedBetween<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyCreatedBetweenPtr
newCallback_Search_onlyCreatedBetween(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyCreatedBetween<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_onlyModifiedBetween : public Callback_Search_onlyModifiedBetween_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_onlyModifiedBetween(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyModifiedBetween(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_onlyModifiedBetweenPtr
newCallback_Search_onlyModifiedBetween(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyModifiedBetween<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyModifiedBetweenPtr
newCallback_Search_onlyModifiedBetween(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyModifiedBetween<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_onlyModifiedBetweenPtr
newCallback_Search_onlyModifiedBetween(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyModifiedBetween<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyModifiedBetweenPtr
newCallback_Search_onlyModifiedBetween(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyModifiedBetween<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_onlyModifiedBetween : public Callback_Search_onlyModifiedBetween_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_onlyModifiedBetween(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyModifiedBetween(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_onlyModifiedBetweenPtr
newCallback_Search_onlyModifiedBetween(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyModifiedBetween<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyModifiedBetweenPtr
newCallback_Search_onlyModifiedBetween(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyModifiedBetween<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyModifiedBetweenPtr
newCallback_Search_onlyModifiedBetween(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyModifiedBetween<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyModifiedBetweenPtr
newCallback_Search_onlyModifiedBetween(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyModifiedBetween<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_onlyAnnotatedBetween : public Callback_Search_onlyAnnotatedBetween_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_onlyAnnotatedBetween(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyAnnotatedBetween(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_onlyAnnotatedBetweenPtr
newCallback_Search_onlyAnnotatedBetween(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedBetween<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyAnnotatedBetweenPtr
newCallback_Search_onlyAnnotatedBetween(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedBetween<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_onlyAnnotatedBetweenPtr
newCallback_Search_onlyAnnotatedBetween(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedBetween<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyAnnotatedBetweenPtr
newCallback_Search_onlyAnnotatedBetween(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedBetween<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_onlyAnnotatedBetween : public Callback_Search_onlyAnnotatedBetween_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_onlyAnnotatedBetween(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyAnnotatedBetween(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_onlyAnnotatedBetweenPtr
newCallback_Search_onlyAnnotatedBetween(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedBetween<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyAnnotatedBetweenPtr
newCallback_Search_onlyAnnotatedBetween(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedBetween<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyAnnotatedBetweenPtr
newCallback_Search_onlyAnnotatedBetween(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedBetween<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyAnnotatedBetweenPtr
newCallback_Search_onlyAnnotatedBetween(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedBetween<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_onlyAnnotatedBy : public Callback_Search_onlyAnnotatedBy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_onlyAnnotatedBy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyAnnotatedBy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_onlyAnnotatedByPtr
newCallback_Search_onlyAnnotatedBy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedBy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyAnnotatedByPtr
newCallback_Search_onlyAnnotatedBy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedBy<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_onlyAnnotatedByPtr
newCallback_Search_onlyAnnotatedBy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedBy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyAnnotatedByPtr
newCallback_Search_onlyAnnotatedBy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedBy<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_onlyAnnotatedBy : public Callback_Search_onlyAnnotatedBy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_onlyAnnotatedBy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyAnnotatedBy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_onlyAnnotatedByPtr
newCallback_Search_onlyAnnotatedBy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedBy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyAnnotatedByPtr
newCallback_Search_onlyAnnotatedBy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedBy<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyAnnotatedByPtr
newCallback_Search_onlyAnnotatedBy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedBy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyAnnotatedByPtr
newCallback_Search_onlyAnnotatedBy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedBy<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_notAnnotatedBy : public Callback_Search_notAnnotatedBy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_notAnnotatedBy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_notAnnotatedBy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_notAnnotatedByPtr
newCallback_Search_notAnnotatedBy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_notAnnotatedBy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_notAnnotatedByPtr
newCallback_Search_notAnnotatedBy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_notAnnotatedBy<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_notAnnotatedByPtr
newCallback_Search_notAnnotatedBy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_notAnnotatedBy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_notAnnotatedByPtr
newCallback_Search_notAnnotatedBy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_notAnnotatedBy<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_notAnnotatedBy : public Callback_Search_notAnnotatedBy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_notAnnotatedBy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_notAnnotatedBy(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_notAnnotatedByPtr
newCallback_Search_notAnnotatedBy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_notAnnotatedBy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_notAnnotatedByPtr
newCallback_Search_notAnnotatedBy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_notAnnotatedBy<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_notAnnotatedByPtr
newCallback_Search_notAnnotatedBy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_notAnnotatedBy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_notAnnotatedByPtr
newCallback_Search_notAnnotatedBy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_notAnnotatedBy<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_onlyAnnotatedWith : public Callback_Search_onlyAnnotatedWith_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_onlyAnnotatedWith(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyAnnotatedWith(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_onlyAnnotatedWithPtr
newCallback_Search_onlyAnnotatedWith(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedWith<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyAnnotatedWithPtr
newCallback_Search_onlyAnnotatedWith(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedWith<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_onlyAnnotatedWithPtr
newCallback_Search_onlyAnnotatedWith(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedWith<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_onlyAnnotatedWithPtr
newCallback_Search_onlyAnnotatedWith(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_onlyAnnotatedWith<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_onlyAnnotatedWith : public Callback_Search_onlyAnnotatedWith_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_onlyAnnotatedWith(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_onlyAnnotatedWith(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_onlyAnnotatedWithPtr
newCallback_Search_onlyAnnotatedWith(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedWith<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyAnnotatedWithPtr
newCallback_Search_onlyAnnotatedWith(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedWith<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyAnnotatedWithPtr
newCallback_Search_onlyAnnotatedWith(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedWith<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_onlyAnnotatedWithPtr
newCallback_Search_onlyAnnotatedWith(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_onlyAnnotatedWith<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_addOrderByAsc : public Callback_Search_addOrderByAsc_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_addOrderByAsc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addOrderByAsc(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_addOrderByAscPtr
newCallback_Search_addOrderByAsc(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_addOrderByAsc<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_addOrderByAscPtr
newCallback_Search_addOrderByAsc(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_addOrderByAsc<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_addOrderByAscPtr
newCallback_Search_addOrderByAsc(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_addOrderByAsc<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_addOrderByAscPtr
newCallback_Search_addOrderByAsc(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_addOrderByAsc<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_addOrderByAsc : public Callback_Search_addOrderByAsc_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_addOrderByAsc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addOrderByAsc(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_addOrderByAscPtr
newCallback_Search_addOrderByAsc(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_addOrderByAsc<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_addOrderByAscPtr
newCallback_Search_addOrderByAsc(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_addOrderByAsc<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_addOrderByAscPtr
newCallback_Search_addOrderByAsc(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_addOrderByAsc<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_addOrderByAscPtr
newCallback_Search_addOrderByAsc(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_addOrderByAsc<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_addOrderByDesc : public Callback_Search_addOrderByDesc_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_addOrderByDesc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addOrderByDesc(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_addOrderByDescPtr
newCallback_Search_addOrderByDesc(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_addOrderByDesc<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_addOrderByDescPtr
newCallback_Search_addOrderByDesc(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_addOrderByDesc<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_addOrderByDescPtr
newCallback_Search_addOrderByDesc(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_addOrderByDesc<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_addOrderByDescPtr
newCallback_Search_addOrderByDesc(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_addOrderByDesc<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_addOrderByDesc : public Callback_Search_addOrderByDesc_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_addOrderByDesc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_addOrderByDesc(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_addOrderByDescPtr
newCallback_Search_addOrderByDesc(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_addOrderByDesc<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_addOrderByDescPtr
newCallback_Search_addOrderByDesc(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_addOrderByDesc<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_addOrderByDescPtr
newCallback_Search_addOrderByDesc(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_addOrderByDesc<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_addOrderByDescPtr
newCallback_Search_addOrderByDesc(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_addOrderByDesc<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_unordered : public Callback_Search_unordered_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_unordered(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_unordered(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_unorderedPtr
newCallback_Search_unordered(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_unordered<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_unorderedPtr
newCallback_Search_unordered(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_unordered<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_unorderedPtr
newCallback_Search_unordered(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_unordered<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_unorderedPtr
newCallback_Search_unordered(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_unordered<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_unordered : public Callback_Search_unordered_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_unordered(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_unordered(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_unorderedPtr
newCallback_Search_unordered(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_unordered<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_unorderedPtr
newCallback_Search_unordered(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_unordered<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_unorderedPtr
newCallback_Search_unordered(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_unordered<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_unorderedPtr
newCallback_Search_unordered(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_unordered<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_fetchAnnotations : public Callback_Search_fetchAnnotations_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_fetchAnnotations(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_fetchAnnotations(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_fetchAnnotationsPtr
newCallback_Search_fetchAnnotations(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_fetchAnnotations<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_fetchAnnotationsPtr
newCallback_Search_fetchAnnotations(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_fetchAnnotations<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_fetchAnnotationsPtr
newCallback_Search_fetchAnnotations(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_fetchAnnotations<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_fetchAnnotationsPtr
newCallback_Search_fetchAnnotations(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_fetchAnnotations<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_fetchAnnotations : public Callback_Search_fetchAnnotations_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_fetchAnnotations(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_fetchAnnotations(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_fetchAnnotationsPtr
newCallback_Search_fetchAnnotations(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_fetchAnnotations<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_fetchAnnotationsPtr
newCallback_Search_fetchAnnotations(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_fetchAnnotations<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_fetchAnnotationsPtr
newCallback_Search_fetchAnnotations(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_fetchAnnotations<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_fetchAnnotationsPtr
newCallback_Search_fetchAnnotations(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_fetchAnnotations<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_fetchAlso : public Callback_Search_fetchAlso_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_fetchAlso(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_fetchAlso(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_fetchAlsoPtr
newCallback_Search_fetchAlso(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_fetchAlso<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_fetchAlsoPtr
newCallback_Search_fetchAlso(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_fetchAlso<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_fetchAlsoPtr
newCallback_Search_fetchAlso(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_fetchAlso<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_fetchAlsoPtr
newCallback_Search_fetchAlso(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_fetchAlso<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_fetchAlso : public Callback_Search_fetchAlso_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_fetchAlso(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_fetchAlso(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_fetchAlsoPtr
newCallback_Search_fetchAlso(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_fetchAlso<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_fetchAlsoPtr
newCallback_Search_fetchAlso(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_fetchAlso<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_fetchAlsoPtr
newCallback_Search_fetchAlso(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_fetchAlso<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_fetchAlsoPtr
newCallback_Search_fetchAlso(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_fetchAlso<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_resetDefaults : public Callback_Search_resetDefaults_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_resetDefaults(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_resetDefaults(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_resetDefaultsPtr
newCallback_Search_resetDefaults(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_resetDefaults<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_resetDefaultsPtr
newCallback_Search_resetDefaults(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_resetDefaults<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_resetDefaultsPtr
newCallback_Search_resetDefaults(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_resetDefaults<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_resetDefaultsPtr
newCallback_Search_resetDefaults(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_resetDefaults<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_resetDefaults : public Callback_Search_resetDefaults_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_resetDefaults(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_resetDefaults(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_resetDefaultsPtr
newCallback_Search_resetDefaults(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_resetDefaults<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_resetDefaultsPtr
newCallback_Search_resetDefaults(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_resetDefaults<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_resetDefaultsPtr
newCallback_Search_resetDefaults(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_resetDefaults<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_resetDefaultsPtr
newCallback_Search_resetDefaults(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_resetDefaults<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_byGroupForTags : public Callback_Search_byGroupForTags_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_byGroupForTags(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byGroupForTags(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_byGroupForTagsPtr
newCallback_Search_byGroupForTags(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byGroupForTags<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byGroupForTagsPtr
newCallback_Search_byGroupForTags(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byGroupForTags<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_byGroupForTagsPtr
newCallback_Search_byGroupForTags(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byGroupForTags<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byGroupForTagsPtr
newCallback_Search_byGroupForTags(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byGroupForTags<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_byGroupForTags : public Callback_Search_byGroupForTags_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_byGroupForTags(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byGroupForTags(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_byGroupForTagsPtr
newCallback_Search_byGroupForTags(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byGroupForTags<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byGroupForTagsPtr
newCallback_Search_byGroupForTags(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byGroupForTags<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byGroupForTagsPtr
newCallback_Search_byGroupForTags(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byGroupForTags<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byGroupForTagsPtr
newCallback_Search_byGroupForTags(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byGroupForTags<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_byTagForGroups : public Callback_Search_byTagForGroups_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_byTagForGroups(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byTagForGroups(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_byTagForGroupsPtr
newCallback_Search_byTagForGroups(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byTagForGroups<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byTagForGroupsPtr
newCallback_Search_byTagForGroups(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byTagForGroups<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_byTagForGroupsPtr
newCallback_Search_byTagForGroups(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byTagForGroups<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byTagForGroupsPtr
newCallback_Search_byTagForGroups(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byTagForGroups<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_byTagForGroups : public Callback_Search_byTagForGroups_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_byTagForGroups(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byTagForGroups(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_byTagForGroupsPtr
newCallback_Search_byTagForGroups(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byTagForGroups<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byTagForGroupsPtr
newCallback_Search_byTagForGroups(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byTagForGroups<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byTagForGroupsPtr
newCallback_Search_byTagForGroups(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byTagForGroups<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byTagForGroupsPtr
newCallback_Search_byTagForGroups(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byTagForGroups<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_byFullText : public Callback_Search_byFullText_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_byFullText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byFullText(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_byFullTextPtr
newCallback_Search_byFullText(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byFullText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byFullTextPtr
newCallback_Search_byFullText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byFullText<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_byFullTextPtr
newCallback_Search_byFullText(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byFullText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byFullTextPtr
newCallback_Search_byFullText(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byFullText<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_byFullText : public Callback_Search_byFullText_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_byFullText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byFullText(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_byFullTextPtr
newCallback_Search_byFullText(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byFullText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byFullTextPtr
newCallback_Search_byFullText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byFullText<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byFullTextPtr
newCallback_Search_byFullText(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byFullText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byFullTextPtr
newCallback_Search_byFullText(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byFullText<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_byLuceneQueryBuilder : public Callback_Search_byLuceneQueryBuilder_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_byLuceneQueryBuilder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byLuceneQueryBuilder(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_byLuceneQueryBuilderPtr
newCallback_Search_byLuceneQueryBuilder(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byLuceneQueryBuilder<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byLuceneQueryBuilderPtr
newCallback_Search_byLuceneQueryBuilder(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byLuceneQueryBuilder<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_byLuceneQueryBuilderPtr
newCallback_Search_byLuceneQueryBuilder(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byLuceneQueryBuilder<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byLuceneQueryBuilderPtr
newCallback_Search_byLuceneQueryBuilder(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byLuceneQueryBuilder<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_byLuceneQueryBuilder : public Callback_Search_byLuceneQueryBuilder_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_byLuceneQueryBuilder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byLuceneQueryBuilder(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_byLuceneQueryBuilderPtr
newCallback_Search_byLuceneQueryBuilder(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byLuceneQueryBuilder<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byLuceneQueryBuilderPtr
newCallback_Search_byLuceneQueryBuilder(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byLuceneQueryBuilder<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byLuceneQueryBuilderPtr
newCallback_Search_byLuceneQueryBuilder(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byLuceneQueryBuilder<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byLuceneQueryBuilderPtr
newCallback_Search_byLuceneQueryBuilder(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byLuceneQueryBuilder<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_bySimilarTerms : public Callback_Search_bySimilarTerms_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_bySimilarTerms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_bySimilarTerms(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_bySimilarTermsPtr
newCallback_Search_bySimilarTerms(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_bySimilarTerms<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_bySimilarTermsPtr
newCallback_Search_bySimilarTerms(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_bySimilarTerms<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_bySimilarTermsPtr
newCallback_Search_bySimilarTerms(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_bySimilarTerms<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_bySimilarTermsPtr
newCallback_Search_bySimilarTerms(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_bySimilarTerms<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_bySimilarTerms : public Callback_Search_bySimilarTerms_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_bySimilarTerms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_bySimilarTerms(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_bySimilarTermsPtr
newCallback_Search_bySimilarTerms(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_bySimilarTerms<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_bySimilarTermsPtr
newCallback_Search_bySimilarTerms(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_bySimilarTerms<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_bySimilarTermsPtr
newCallback_Search_bySimilarTerms(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_bySimilarTerms<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_bySimilarTermsPtr
newCallback_Search_bySimilarTerms(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_bySimilarTerms<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_byHqlQuery : public Callback_Search_byHqlQuery_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_byHqlQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byHqlQuery(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_byHqlQueryPtr
newCallback_Search_byHqlQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byHqlQuery<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byHqlQueryPtr
newCallback_Search_byHqlQuery(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byHqlQuery<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_byHqlQueryPtr
newCallback_Search_byHqlQuery(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byHqlQuery<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byHqlQueryPtr
newCallback_Search_byHqlQuery(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byHqlQuery<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_byHqlQuery : public Callback_Search_byHqlQuery_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_byHqlQuery(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byHqlQuery(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_byHqlQueryPtr
newCallback_Search_byHqlQuery(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byHqlQuery<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byHqlQueryPtr
newCallback_Search_byHqlQuery(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byHqlQuery<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byHqlQueryPtr
newCallback_Search_byHqlQuery(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byHqlQuery<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byHqlQueryPtr
newCallback_Search_byHqlQuery(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byHqlQuery<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_bySomeMustNone : public Callback_Search_bySomeMustNone_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_bySomeMustNone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_bySomeMustNone(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_bySomeMustNonePtr
newCallback_Search_bySomeMustNone(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_bySomeMustNone<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_bySomeMustNonePtr
newCallback_Search_bySomeMustNone(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_bySomeMustNone<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_bySomeMustNonePtr
newCallback_Search_bySomeMustNone(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_bySomeMustNone<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_bySomeMustNonePtr
newCallback_Search_bySomeMustNone(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_bySomeMustNone<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_bySomeMustNone : public Callback_Search_bySomeMustNone_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_bySomeMustNone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_bySomeMustNone(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_bySomeMustNonePtr
newCallback_Search_bySomeMustNone(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_bySomeMustNone<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_bySomeMustNonePtr
newCallback_Search_bySomeMustNone(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_bySomeMustNone<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_bySomeMustNonePtr
newCallback_Search_bySomeMustNone(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_bySomeMustNone<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_bySomeMustNonePtr
newCallback_Search_bySomeMustNone(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_bySomeMustNone<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_byAnnotatedWith : public Callback_Search_byAnnotatedWith_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_byAnnotatedWith(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byAnnotatedWith(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_byAnnotatedWithPtr
newCallback_Search_byAnnotatedWith(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byAnnotatedWith<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byAnnotatedWithPtr
newCallback_Search_byAnnotatedWith(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byAnnotatedWith<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_byAnnotatedWithPtr
newCallback_Search_byAnnotatedWith(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byAnnotatedWith<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_byAnnotatedWithPtr
newCallback_Search_byAnnotatedWith(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_byAnnotatedWith<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_byAnnotatedWith : public Callback_Search_byAnnotatedWith_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_byAnnotatedWith(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_byAnnotatedWith(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_byAnnotatedWithPtr
newCallback_Search_byAnnotatedWith(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byAnnotatedWith<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byAnnotatedWithPtr
newCallback_Search_byAnnotatedWith(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byAnnotatedWith<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byAnnotatedWithPtr
newCallback_Search_byAnnotatedWith(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byAnnotatedWith<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_byAnnotatedWithPtr
newCallback_Search_byAnnotatedWith(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_byAnnotatedWith<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_clearQueries : public Callback_Search_clearQueries_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_clearQueries(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clearQueries(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_clearQueriesPtr
newCallback_Search_clearQueries(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_clearQueries<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_clearQueriesPtr
newCallback_Search_clearQueries(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_clearQueries<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_clearQueriesPtr
newCallback_Search_clearQueries(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_clearQueries<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_clearQueriesPtr
newCallback_Search_clearQueries(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_clearQueries<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_clearQueries : public Callback_Search_clearQueries_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_clearQueries(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_clearQueries(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_clearQueriesPtr
newCallback_Search_clearQueries(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_clearQueries<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_clearQueriesPtr
newCallback_Search_clearQueries(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_clearQueries<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_clearQueriesPtr
newCallback_Search_clearQueries(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_clearQueries<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_clearQueriesPtr
newCallback_Search_clearQueries(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_clearQueries<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_and : public Callback_Search_and_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_and(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_and(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_andPtr
newCallback_Search_and(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_and<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_andPtr
newCallback_Search_and(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_and<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_andPtr
newCallback_Search_and(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_and<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_andPtr
newCallback_Search_and(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_and<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_and : public Callback_Search_and_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_and(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_and(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_andPtr
newCallback_Search_and(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_and<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_andPtr
newCallback_Search_and(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_and<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_andPtr
newCallback_Search_and(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_and<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_andPtr
newCallback_Search_and(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_and<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_or : public Callback_Search_or_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_or(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_or(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_orPtr
newCallback_Search_or(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_or<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_orPtr
newCallback_Search_or(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_or<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_orPtr
newCallback_Search_or(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_or<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_orPtr
newCallback_Search_or(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_or<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_or : public Callback_Search_or_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_or(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_or(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_orPtr
newCallback_Search_or(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_or<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_orPtr
newCallback_Search_or(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_or<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_orPtr
newCallback_Search_or(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_or<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_orPtr
newCallback_Search_or(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_or<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_not : public Callback_Search_not_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_not(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_not(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_notPtr
newCallback_Search_not(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_not<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_notPtr
newCallback_Search_not(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_not<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_notPtr
newCallback_Search_not(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_not<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_notPtr
newCallback_Search_not(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_not<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_not : public Callback_Search_not_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_not(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_not(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_notPtr
newCallback_Search_not(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_not<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_notPtr
newCallback_Search_not(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_not<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_notPtr
newCallback_Search_not(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_not<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_notPtr
newCallback_Search_not(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_not<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Search_hasNext : public Callback_Search_hasNext_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Search_hasNext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_hasNext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_hasNextPtr
newCallback_Search_hasNext(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_hasNext<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_hasNextPtr
newCallback_Search_hasNext(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_hasNext<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_hasNext : public Callback_Search_hasNext_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Search_hasNext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_hasNext(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_hasNextPtr
newCallback_Search_hasNext(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_hasNext<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_hasNextPtr
newCallback_Search_hasNext(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_hasNext<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_next : public Callback_Search_next_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::model::IObjectPtr&);

    CallbackNC_Search_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IObjectPtr __ret;
        try
        {
            __ret = __proxy->end_next(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_nextPtr
newCallback_Search_next(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_next<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_nextPtr
newCallback_Search_next(T* instance, void (T::*cb)(const ::omero::model::IObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_next<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_next : public Callback_Search_next_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::model::IObjectPtr&, const CT&);

    Callback_Search_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::omero::model::IObjectPtr __ret;
        try
        {
            __ret = __proxy->end_next(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_nextPtr
newCallback_Search_next(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::model::IObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_next<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_nextPtr
newCallback_Search_next(T* instance, void (T::*cb)(const ::omero::model::IObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_next<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_results : public Callback_Search_results_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::IObjectList&);

    CallbackNC_Search_results(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IObjectList __ret;
        try
        {
            __ret = __proxy->end_results(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_resultsPtr
newCallback_Search_results(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IObjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_results<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_resultsPtr
newCallback_Search_results(T* instance, void (T::*cb)(const ::omero::api::IObjectList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_results<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_results : public Callback_Search_results_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::IObjectList&, const CT&);

    Callback_Search_results(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::omero::api::IObjectList __ret;
        try
        {
            __ret = __proxy->end_results(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_resultsPtr
newCallback_Search_results(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::IObjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_results<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_resultsPtr
newCallback_Search_results(T* instance, void (T::*cb)(const ::omero::api::IObjectList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_results<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_currentMetadata : public Callback_Search_currentMetadata_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::SearchMetadata&);

    CallbackNC_Search_currentMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SearchMetadata __ret;
        try
        {
            __ret = __proxy->end_currentMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_currentMetadataPtr
newCallback_Search_currentMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SearchMetadata&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_currentMetadata<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_currentMetadataPtr
newCallback_Search_currentMetadata(T* instance, void (T::*cb)(const ::omero::api::SearchMetadata&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_currentMetadata<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_currentMetadata : public Callback_Search_currentMetadata_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::SearchMetadata&, const CT&);

    Callback_Search_currentMetadata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SearchMetadata __ret;
        try
        {
            __ret = __proxy->end_currentMetadata(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_currentMetadataPtr
newCallback_Search_currentMetadata(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SearchMetadata&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_currentMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_currentMetadataPtr
newCallback_Search_currentMetadata(T* instance, void (T::*cb)(const ::omero::api::SearchMetadata&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_currentMetadata<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_currentMetadataList : public Callback_Search_currentMetadataList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::omero::api::SearchMetadataList&);

    CallbackNC_Search_currentMetadataList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SearchMetadataList __ret;
        try
        {
            __ret = __proxy->end_currentMetadataList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_currentMetadataListPtr
newCallback_Search_currentMetadataList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SearchMetadataList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_currentMetadataList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_currentMetadataListPtr
newCallback_Search_currentMetadataList(T* instance, void (T::*cb)(const ::omero::api::SearchMetadataList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_currentMetadataList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_currentMetadataList : public Callback_Search_currentMetadataList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::omero::api::SearchMetadataList&, const CT&);

    Callback_Search_currentMetadataList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        ::omero::api::SearchMetadataList __ret;
        try
        {
            __ret = __proxy->end_currentMetadataList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_currentMetadataListPtr
newCallback_Search_currentMetadataList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::omero::api::SearchMetadataList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_currentMetadataList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_currentMetadataListPtr
newCallback_Search_currentMetadataList(T* instance, void (T::*cb)(const ::omero::api::SearchMetadataList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_currentMetadataList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Search_remove : public Callback_Search_remove_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Search_remove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_remove(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)();
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
#endif
        }
    }

    Response response;
};

template<class T> Callback_Search_removePtr
newCallback_Search_remove(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_remove<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_removePtr
newCallback_Search_remove(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_remove<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Search_removePtr
newCallback_Search_remove(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_remove<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Search_removePtr
newCallback_Search_remove(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Search_remove<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Search_remove : public Callback_Search_remove_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Search_remove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::omero::api::SearchPrx __proxy = ::omero::api::SearchPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_remove(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Search_removePtr
newCallback_Search_remove(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_remove<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_removePtr
newCallback_Search_remove(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_remove<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Search_removePtr
newCallback_Search_remove(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_remove<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Search_removePtr
newCallback_Search_remove(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Search_remove<T, CT>(instance, 0, excb, sentcb);
}

}

}

#endif
