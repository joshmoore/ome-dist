   /*
   **   Generated by blitz/templates/resouces/combined.vm
   **   See ../../README.h for information on these types.
   **
   **   Copyright 2007, 2008 Glencoe Software, Inc. All rights reserved.
   **   Use is subject to license terms supplied in LICENSE.txt
   **
   */
#ifndef CHANNELI_H
#define CHANNELI_H
#include <omero/IceNoWarnPush.h>
#include <omero/RTypes.h>
#include <omero/model/RTypes.h>
#include <omero/model/IObject.h>
#include <omero/model/Channel.h>
#include <omero/IceNoWarnPop.h>
#include <omero/ClientErrors.h>
#include <omero/model/DetailsI.h>
#include <omero/model/NamedValue.h>
#include <omero/templates.h>
#include <IceUtil/Config.h>
#if ICE_INT_VERSION / 100 >= 304
#   include <Ice/Handle.h>
#else
#   include <IceUtil/Handle.h>
#endif
#ifndef OMERO_CLIENT
#   ifdef OMERO_CLIENT_EXPORTS
#       define OMERO_CLIENT ICE_DECLSPEC_EXPORT
#   else
#       define OMERO_CLIENT ICE_DECLSPEC_IMPORT
#   endif
#endif
namespace omero {
  namespace model {
    class OMERO_CLIENT ChannelI;
  }
}
#if ICE_INT_VERSION / 100 >= 304
namespace IceInternal {
  OMERO_CLIENT ::Ice::Object* upCast(::omero::model::ChannelI*);
}
#endif
namespace omero {
  namespace model {
#if ICE_INT_VERSION / 100 >= 304
  typedef IceInternal::Handle<ChannelI> ChannelIPtr;
#else
  typedef IceUtil::Handle<ChannelI> ChannelIPtr;
#endif
    class OMERO_CLIENT ChannelI : virtual public Channel {
   public:
      static const std::string STATSINFO;
      static const std::string RED;
      static const std::string GREEN;
      static const std::string BLUE;
      static const std::string ALPHA;
      static const std::string LOOKUPTABLE;
      static const std::string LOGICALCHANNEL;
      static const std::string PIXELS;
      static const std::string ANNOTATIONLINKS;
      static const std::string DETAILS;
    protected:
      void errorIfUnloaded();
      void throwNullCollectionException(std::string propertyName);
      virtual void toggleCollectionsLoaded(bool load);
      virtual ~ChannelI();
    public:
      ChannelI();
      ChannelI(omero::RLongPtr idPtr, bool isLoaded = false);
      ChannelI(Ice::Long id, bool isLoaded = false);
      virtual void unload(const Ice::Current& current = Ice::Current());
      virtual bool isLoaded(const Ice::Current& current = Ice::Current());
      virtual void unloadCollections(const Ice::Current& current = Ice::Current());
      virtual bool isGlobal(const Ice::Current& current = Ice::Current());
      virtual bool isMutable(const Ice::Current& current = Ice::Current());
      virtual bool isAnnotated(const Ice::Current& current = Ice::Current());
      virtual bool isLink(const Ice::Current& current = Ice::Current());
      virtual omero::model::IObjectPtr shallowCopy(const Ice::Current& current = Ice::Current());
      virtual omero::model::IObjectPtr proxy(const Ice::Current& current = Ice::Current());
      virtual omero::model::DetailsPtr getDetails(const Ice::Current& current = Ice::Current());
      virtual void unloadDetails(const Ice::Current& current = Ice::Current());
      virtual omero::RLongPtr getId(const Ice::Current& current = Ice::Current());
      virtual void setId( const omero::RLongPtr& id, const Ice::Current& current = Ice::Current() );
      virtual omero::RIntPtr getVersion(const Ice::Current& current = Ice::Current());
      virtual void setVersion( const omero::RIntPtr& version, const Ice::Current& current = Ice::Current() );

      //
      //  Channel.statsInfo
      //
      virtual void unloadStatsInfo();
      virtual omero::model::StatsInfoPtr getStatsInfo(const Ice::Current& current = Ice::Current());
      virtual void setStatsInfo(const omero::model::StatsInfoPtr& _statsInfo, const Ice::Current& current = Ice::Current());

      //
      //  Channel.red
      //
      virtual void unloadRed();
      virtual omero::RIntPtr getRed(const Ice::Current& current = Ice::Current());
      virtual void setRed(const omero::RIntPtr& _red, const Ice::Current& current = Ice::Current());

      //
      //  Channel.green
      //
      virtual void unloadGreen();
      virtual omero::RIntPtr getGreen(const Ice::Current& current = Ice::Current());
      virtual void setGreen(const omero::RIntPtr& _green, const Ice::Current& current = Ice::Current());

      //
      //  Channel.blue
      //
      virtual void unloadBlue();
      virtual omero::RIntPtr getBlue(const Ice::Current& current = Ice::Current());
      virtual void setBlue(const omero::RIntPtr& _blue, const Ice::Current& current = Ice::Current());

      //
      //  Channel.alpha
      //
      virtual void unloadAlpha();
      virtual omero::RIntPtr getAlpha(const Ice::Current& current = Ice::Current());
      virtual void setAlpha(const omero::RIntPtr& _alpha, const Ice::Current& current = Ice::Current());

      //
      //  Channel.lookupTable
      //
      virtual void unloadLookupTable();
      virtual omero::RStringPtr getLookupTable(const Ice::Current& current = Ice::Current());
      virtual void setLookupTable(const omero::RStringPtr& _lookupTable, const Ice::Current& current = Ice::Current());

      //
      //  Channel.logicalChannel
      //
      virtual void unloadLogicalChannel();
      virtual omero::model::LogicalChannelPtr getLogicalChannel(const Ice::Current& current = Ice::Current());
      virtual void setLogicalChannel(const omero::model::LogicalChannelPtr& _logicalChannel, const Ice::Current& current = Ice::Current());

      //
      //  Channel.pixels
      //
      virtual void unloadPixels();
      virtual omero::model::PixelsPtr getPixels(const Ice::Current& current = Ice::Current());
      virtual void setPixels(const omero::model::PixelsPtr& _pixels, const Ice::Current& current = Ice::Current());

      //
      //  Channel.annotationLinks
      //
      virtual void unloadAnnotationLinks(const Ice::Current& current = Ice::Current());
    protected:
      virtual ChannelAnnotationLinksSeq getAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual void setAnnotationLinks(const ChannelAnnotationLinksSeq& _annotationLinks, const Ice::Current& current = Ice::Current());
    public:
      virtual bool isAnnotationLinksLoaded();
      virtual Ice::Int sizeOfAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual ChannelAnnotationLinksSeq copyAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual ChannelAnnotationLinksSeq::iterator beginAnnotationLinks();
      virtual ChannelAnnotationLinksSeq::iterator endAnnotationLinks();
      virtual void addChannelAnnotationLink(const ChannelAnnotationLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void addAllChannelAnnotationLinkSet(const ChannelAnnotationLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void removeChannelAnnotationLink(const ChannelAnnotationLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void removeAllChannelAnnotationLinkSet(const ChannelAnnotationLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void clearAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual void reloadAnnotationLinks(const ChannelPtr& toCopy, const Ice::Current& current = Ice::Current());
      virtual omero::sys::CountMap getAnnotationLinksCountPerOwner(const Ice::Current& current = Ice::Current());
      virtual ChannelAnnotationLinkPtr linkAnnotation(const AnnotationPtr& addition, const Ice::Current& current = Ice::Current());
      virtual void addChannelAnnotationLinkToBoth(const ChannelAnnotationLinkPtr& link, bool /*unused*/, const Ice::Current& current = Ice::Current());
      virtual ChannelAnnotationLinksSeq findChannelAnnotationLink(const AnnotationPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void unlinkAnnotation(const AnnotationPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void removeChannelAnnotationLinkFromBoth(const ChannelAnnotationLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
       virtual ChannelLinkedAnnotationSeq linkedAnnotationList(const Ice::Current& current = Ice::Current());
 };

}}
#endif // CHANNELI_H
