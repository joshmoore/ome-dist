   /*
   **   Generated by blitz/templates/resouces/combined.vm
   **   See ../../README.h for information on these types.
   **
   **   Copyright 2007, 2008 Glencoe Software, Inc. All rights reserved.
   **   Use is subject to license terms supplied in LICENSE.txt
   **
   */
#ifndef FILESETI_H
#define FILESETI_H
#include <omero/RTypes.h>
#include <omero/ClientErrors.h>
#include <omero/model/IObject.h>
#include <omero/model/DetailsI.h>
#include <omero/model/Fileset.h>
#include <omero/templates.h>
#include <IceUtil/Config.h>
#if ICE_INT_VERSION / 100 >= 304
#   include <Ice/Handle.h>
#else
#   include <IceUtil/Handle.h>
#endif
#ifndef OMERO_API
#   ifdef OMERO_API_EXPORTS
#       define OMERO_API ICE_DECLSPEC_EXPORT
#   else
#       define OMERO_API ICE_DECLSPEC_IMPORT
#   endif
#endif
namespace omero {
  namespace model {
    class OMERO_API FilesetI;
  }
}
#if ICE_INT_VERSION / 100 >= 304
namespace IceInternal {
  OMERO_API ::Ice::Object* upCast(::omero::model::FilesetI*);
}
#endif
namespace omero {
  namespace model {
#if ICE_INT_VERSION / 100 >= 304
  typedef IceInternal::Handle<FilesetI> FilesetIPtr;
#else
  typedef IceUtil::Handle<FilesetI> FilesetIPtr;
#endif
    class OMERO_API FilesetI : virtual public Fileset {
   public:
      static const std::string USEDFILES;
      static const std::string IMAGES;
      static const std::string JOBLINKS;
      static const std::string TEMPLATEPREFIX;
      static const std::string ANNOTATIONLINKS;
      static const std::string DETAILS;
    protected:
      void errorIfUnloaded();
      void throwNullCollectionException(std::string propertyName);
      virtual void toggleCollectionsLoaded(bool load);
      virtual ~FilesetI();
    public:
      FilesetI();
      FilesetI(omero::RLongPtr idPtr, bool isLoaded = false);
      FilesetI(Ice::Long id, bool isLoaded = false);
      virtual void unload(const Ice::Current& current = Ice::Current());
      virtual bool isLoaded(const Ice::Current& current = Ice::Current());
      virtual void unloadCollections(const Ice::Current& current = Ice::Current());
      virtual bool isGlobal(const Ice::Current& current = Ice::Current());
      virtual bool isMutable(const Ice::Current& current = Ice::Current());
      virtual bool isAnnotated(const Ice::Current& current = Ice::Current());
      virtual bool isLink(const Ice::Current& current = Ice::Current());
      virtual omero::model::IObjectPtr shallowCopy(const Ice::Current& current = Ice::Current());
      virtual omero::model::IObjectPtr proxy(const Ice::Current& current = Ice::Current());
      virtual omero::model::DetailsPtr getDetails(const Ice::Current& current = Ice::Current());
      virtual void unloadDetails(const Ice::Current& current = Ice::Current());
      virtual omero::RLongPtr getId(const Ice::Current& current = Ice::Current());
      virtual void setId( const omero::RLongPtr& id, const Ice::Current& current = Ice::Current() );
      virtual omero::RIntPtr getVersion(const Ice::Current& current = Ice::Current());
      virtual void setVersion( const omero::RIntPtr& version, const Ice::Current& current = Ice::Current() );

      //
      //  Fileset.usedFiles
      //
      virtual void unloadUsedFiles(const Ice::Current& current = Ice::Current());
    protected:
      virtual FilesetUsedFilesSeq getUsedFiles(const Ice::Current& current = Ice::Current());
      virtual void setUsedFiles(const FilesetUsedFilesSeq& _usedFiles, const Ice::Current& current = Ice::Current());
    public:
      virtual bool isUsedFilesLoaded();
      virtual Ice::Int sizeOfUsedFiles(const Ice::Current& current = Ice::Current());
      virtual FilesetUsedFilesSeq copyUsedFiles(const Ice::Current& current = Ice::Current());
      virtual FilesetUsedFilesSeq::iterator beginUsedFiles();
      virtual FilesetUsedFilesSeq::iterator endUsedFiles();
      virtual void addFilesetEntry(const FilesetEntryPtr& target, const Ice::Current& current = Ice::Current());
      virtual void addAllFilesetEntrySet(const FilesetUsedFilesSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void removeFilesetEntry(const FilesetEntryPtr& target, const Ice::Current& current = Ice::Current());
      virtual void removeAllFilesetEntrySet(const FilesetUsedFilesSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void clearUsedFiles(const Ice::Current& current = Ice::Current());
      virtual void reloadUsedFiles(const FilesetPtr& toCopy, const Ice::Current& current = Ice::Current());
      virtual FilesetEntryPtr getFilesetEntry(int index, const Ice::Current& current = Ice::Current());
      virtual FilesetEntryPtr setFilesetEntry(int index, const FilesetEntryPtr& element, const Ice::Current& current = Ice::Current());
      virtual FilesetEntryPtr getPrimaryFilesetEntry(const Ice::Current& current = Ice::Current());
      virtual FilesetEntryPtr setPrimaryFilesetEntry(const FilesetEntryPtr& element, const Ice::Current& current = Ice::Current());

      //
      //  Fileset.images
      //
      virtual void unloadImages(const Ice::Current& current = Ice::Current());
    protected:
      virtual FilesetImagesSeq getImages(const Ice::Current& current = Ice::Current());
      virtual void setImages(const FilesetImagesSeq& _images, const Ice::Current& current = Ice::Current());
    public:
      virtual bool isImagesLoaded();
      virtual Ice::Int sizeOfImages(const Ice::Current& current = Ice::Current());
      virtual FilesetImagesSeq copyImages(const Ice::Current& current = Ice::Current());
      virtual FilesetImagesSeq::iterator beginImages();
      virtual FilesetImagesSeq::iterator endImages();
      virtual void addImage(const ImagePtr& target, const Ice::Current& current = Ice::Current());
      virtual void addAllImageSet(const FilesetImagesSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void removeImage(const ImagePtr& target, const Ice::Current& current = Ice::Current());
      virtual void removeAllImageSet(const FilesetImagesSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void clearImages(const Ice::Current& current = Ice::Current());
      virtual void reloadImages(const FilesetPtr& toCopy, const Ice::Current& current = Ice::Current());

      //
      //  Fileset.jobLinks
      //
      virtual void unloadJobLinks(const Ice::Current& current = Ice::Current());
    protected:
      virtual FilesetJobLinksSeq getJobLinks(const Ice::Current& current = Ice::Current());
      virtual void setJobLinks(const FilesetJobLinksSeq& _jobLinks, const Ice::Current& current = Ice::Current());
    public:
      virtual bool isJobLinksLoaded();
      virtual Ice::Int sizeOfJobLinks(const Ice::Current& current = Ice::Current());
      virtual FilesetJobLinksSeq copyJobLinks(const Ice::Current& current = Ice::Current());
      virtual FilesetJobLinksSeq::iterator beginJobLinks();
      virtual FilesetJobLinksSeq::iterator endJobLinks();
      virtual void addFilesetJobLink(const FilesetJobLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void addAllFilesetJobLinkSet(const FilesetJobLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void removeFilesetJobLink(const FilesetJobLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void removeAllFilesetJobLinkSet(const FilesetJobLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void clearJobLinks(const Ice::Current& current = Ice::Current());
      virtual void reloadJobLinks(const FilesetPtr& toCopy, const Ice::Current& current = Ice::Current());
      virtual FilesetJobLinkPtr getFilesetJobLink(int index, const Ice::Current& current = Ice::Current());
      virtual FilesetJobLinkPtr setFilesetJobLink(int index, const FilesetJobLinkPtr& element, const Ice::Current& current = Ice::Current());
      virtual FilesetJobLinkPtr getPrimaryFilesetJobLink(const Ice::Current& current = Ice::Current());
      virtual FilesetJobLinkPtr setPrimaryFilesetJobLink(const FilesetJobLinkPtr& element, const Ice::Current& current = Ice::Current());
      virtual omero::sys::CountMap getJobLinksCountPerOwner(const Ice::Current& current = Ice::Current());
      virtual FilesetJobLinkPtr linkJob(const JobPtr& addition, const Ice::Current& current = Ice::Current());
      virtual void addFilesetJobLinkToBoth(const FilesetJobLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
      virtual FilesetJobLinksSeq findFilesetJobLink(const JobPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void unlinkJob(const JobPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void removeFilesetJobLinkFromBoth(const FilesetJobLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
       virtual FilesetLinkedJobSeq linkedJobList(const Ice::Current& current = Ice::Current());

      //
      //  Fileset.templatePrefix
      //
      virtual void unloadTemplatePrefix();
      virtual omero::RStringPtr getTemplatePrefix(const Ice::Current& current = Ice::Current());
      virtual void setTemplatePrefix(const omero::RStringPtr& _templatePrefix, const Ice::Current& current = Ice::Current());

      //
      //  Fileset.annotationLinks
      //
      virtual void unloadAnnotationLinks(const Ice::Current& current = Ice::Current());
    protected:
      virtual FilesetAnnotationLinksSeq getAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual void setAnnotationLinks(const FilesetAnnotationLinksSeq& _annotationLinks, const Ice::Current& current = Ice::Current());
    public:
      virtual bool isAnnotationLinksLoaded();
      virtual Ice::Int sizeOfAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual FilesetAnnotationLinksSeq copyAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual FilesetAnnotationLinksSeq::iterator beginAnnotationLinks();
      virtual FilesetAnnotationLinksSeq::iterator endAnnotationLinks();
      virtual void addFilesetAnnotationLink(const FilesetAnnotationLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void addAllFilesetAnnotationLinkSet(const FilesetAnnotationLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void removeFilesetAnnotationLink(const FilesetAnnotationLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void removeAllFilesetAnnotationLinkSet(const FilesetAnnotationLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void clearAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual void reloadAnnotationLinks(const FilesetPtr& toCopy, const Ice::Current& current = Ice::Current());
      virtual omero::sys::CountMap getAnnotationLinksCountPerOwner(const Ice::Current& current = Ice::Current());
      virtual FilesetAnnotationLinkPtr linkAnnotation(const AnnotationPtr& addition, const Ice::Current& current = Ice::Current());
      virtual void addFilesetAnnotationLinkToBoth(const FilesetAnnotationLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
      virtual FilesetAnnotationLinksSeq findFilesetAnnotationLink(const AnnotationPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void unlinkAnnotation(const AnnotationPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void removeFilesetAnnotationLinkFromBoth(const FilesetAnnotationLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
       virtual FilesetLinkedAnnotationSeq linkedAnnotationList(const Ice::Current& current = Ice::Current());
 };

}}
#endif // FILESETI_H
