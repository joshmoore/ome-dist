   /*
   **   Generated by blitz/resources/templates/combined.vm
   **   See ../../README.h for information on these types.
   **
   **   Copyright 2007, 2008 Glencoe Software, Inc. All rights reserved.
   **   Use is subject to license terms supplied in LICENSE.txt
   **
   */
#ifndef FOLDERI_H
#define FOLDERI_H
#include <omero/IceNoWarnPush.h>
#include <omero/RTypes.h>
#include <omero/model/RTypes.h>
#include <omero/model/IObject.h>
#include <omero/model/Folder.h>
#include <omero/IceNoWarnPop.h>
#include <omero/ClientErrors.h>
#include <omero/model/DetailsI.h>
#include <omero/model/NamedValue.h>
#include <omero/templates.h>
#include <IceUtil/Config.h>
#include <Ice/Handle.h>
#ifndef OMERO_CLIENT
#   ifdef OMERO_CLIENT_EXPORTS
#       define OMERO_CLIENT ICE_DECLSPEC_EXPORT
#   else
#       define OMERO_CLIENT ICE_DECLSPEC_IMPORT
#   endif
#endif
namespace omero {
  namespace model {
    class OMERO_CLIENT FolderI;
  }
}
namespace IceInternal {
  OMERO_CLIENT ::Ice::Object* upCast(::omero::model::FolderI*);
}
namespace omero {
  namespace model {
  typedef IceInternal::Handle<FolderI> FolderIPtr;
    class OMERO_CLIENT FolderI : virtual public Folder {
   public:
      static const std::string CHILDFOLDERS;
      static const std::string PARENTFOLDER;
      static const std::string IMAGELINKS;
      static const std::string ROILINKS;
      static const std::string ANNOTATIONLINKS;
      static const std::string NAME;
      static const std::string DESCRIPTION;
      static const std::string DETAILS;
    protected:
      void errorIfUnloaded();
      void throwNullCollectionException(std::string propertyName);
      virtual void toggleCollectionsLoaded(bool load);
      virtual ~FolderI();
    public:
      FolderI();
      FolderI(omero::RLongPtr idPtr, bool isLoaded = false);
      FolderI(Ice::Long id, bool isLoaded = false);
      virtual void unload(const Ice::Current& current = Ice::Current());
      virtual bool isLoaded(const Ice::Current& current = Ice::Current());
      virtual void unloadCollections(const Ice::Current& current = Ice::Current());
      virtual bool isGlobal(const Ice::Current& current = Ice::Current());
      virtual bool isMutable(const Ice::Current& current = Ice::Current());
      virtual bool isAnnotated(const Ice::Current& current = Ice::Current());
      virtual bool isLink(const Ice::Current& current = Ice::Current());
      virtual omero::model::IObjectPtr shallowCopy(const Ice::Current& current = Ice::Current());
      virtual omero::model::IObjectPtr proxy(const Ice::Current& current = Ice::Current());
      virtual omero::model::DetailsPtr getDetails(const Ice::Current& current = Ice::Current());
      virtual void unloadDetails(const Ice::Current& current = Ice::Current());
      virtual omero::RLongPtr getId(const Ice::Current& current = Ice::Current());
      virtual void setId( const omero::RLongPtr& id, const Ice::Current& current = Ice::Current() );
      virtual omero::RIntPtr getVersion(const Ice::Current& current = Ice::Current());
      virtual void setVersion( const omero::RIntPtr& version, const Ice::Current& current = Ice::Current() );

      //
      //  Folder.childFolders
      //
      virtual void unloadChildFolders(const Ice::Current& current = Ice::Current());
    protected:
      virtual FolderChildFoldersSeq getChildFolders(const Ice::Current& current = Ice::Current());
      virtual void setChildFolders(const FolderChildFoldersSeq& _childFolders, const Ice::Current& current = Ice::Current());
    public:
      virtual bool isChildFoldersLoaded();
      virtual Ice::Int sizeOfChildFolders(const Ice::Current& current = Ice::Current());
      virtual FolderChildFoldersSeq copyChildFolders(const Ice::Current& current = Ice::Current());
      virtual FolderChildFoldersSeq::iterator beginChildFolders();
      virtual FolderChildFoldersSeq::iterator endChildFolders();
      virtual void addChildFolders(const FolderPtr& target, const Ice::Current& current = Ice::Current());
      virtual void addAllChildFoldersSet(const FolderChildFoldersSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void removeChildFolders(const FolderPtr& target, const Ice::Current& current = Ice::Current());
      virtual void removeAllChildFoldersSet(const FolderChildFoldersSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void clearChildFolders(const Ice::Current& current = Ice::Current());
      virtual void reloadChildFolders(const FolderPtr& toCopy, const Ice::Current& current = Ice::Current());

      //
      //  Folder.parentFolder
      //
      virtual void unloadParentFolder();
      virtual omero::model::FolderPtr getParentFolder(const Ice::Current& current = Ice::Current());
      virtual void setParentFolder(const omero::model::FolderPtr& _parentFolder, const Ice::Current& current = Ice::Current());

      //
      //  Folder.imageLinks
      //
      virtual void unloadImageLinks(const Ice::Current& current = Ice::Current());
    protected:
      virtual FolderImageLinksSeq getImageLinks(const Ice::Current& current = Ice::Current());
      virtual void setImageLinks(const FolderImageLinksSeq& _imageLinks, const Ice::Current& current = Ice::Current());
    public:
      virtual bool isImageLinksLoaded();
      virtual Ice::Int sizeOfImageLinks(const Ice::Current& current = Ice::Current());
      virtual FolderImageLinksSeq copyImageLinks(const Ice::Current& current = Ice::Current());
      virtual FolderImageLinksSeq::iterator beginImageLinks();
      virtual FolderImageLinksSeq::iterator endImageLinks();
      virtual void addFolderImageLink(const FolderImageLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void addAllFolderImageLinkSet(const FolderImageLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void removeFolderImageLink(const FolderImageLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void removeAllFolderImageLinkSet(const FolderImageLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void clearImageLinks(const Ice::Current& current = Ice::Current());
      virtual void reloadImageLinks(const FolderPtr& toCopy, const Ice::Current& current = Ice::Current());
      virtual omero::sys::CountMap getImageLinksCountPerOwner(const Ice::Current& current = Ice::Current());
      virtual FolderImageLinkPtr linkImage(const ImagePtr& addition, const Ice::Current& current = Ice::Current());
      virtual void addFolderImageLinkToBoth(const FolderImageLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
      virtual FolderImageLinksSeq findFolderImageLink(const ImagePtr& removal, const Ice::Current& current = Ice::Current());
      virtual void unlinkImage(const ImagePtr& removal, const Ice::Current& current = Ice::Current());
      virtual void removeFolderImageLinkFromBoth(const FolderImageLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
       virtual FolderLinkedImageSeq linkedImageList(const Ice::Current& current = Ice::Current());

      //
      //  Folder.roiLinks
      //
      virtual void unloadRoiLinks(const Ice::Current& current = Ice::Current());
    protected:
      virtual FolderRoiLinksSeq getRoiLinks(const Ice::Current& current = Ice::Current());
      virtual void setRoiLinks(const FolderRoiLinksSeq& _roiLinks, const Ice::Current& current = Ice::Current());
    public:
      virtual bool isRoiLinksLoaded();
      virtual Ice::Int sizeOfRoiLinks(const Ice::Current& current = Ice::Current());
      virtual FolderRoiLinksSeq copyRoiLinks(const Ice::Current& current = Ice::Current());
      virtual FolderRoiLinksSeq::iterator beginRoiLinks();
      virtual FolderRoiLinksSeq::iterator endRoiLinks();
      virtual void addFolderRoiLink(const FolderRoiLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void addAllFolderRoiLinkSet(const FolderRoiLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void removeFolderRoiLink(const FolderRoiLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void removeAllFolderRoiLinkSet(const FolderRoiLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void clearRoiLinks(const Ice::Current& current = Ice::Current());
      virtual void reloadRoiLinks(const FolderPtr& toCopy, const Ice::Current& current = Ice::Current());
      virtual omero::sys::CountMap getRoiLinksCountPerOwner(const Ice::Current& current = Ice::Current());
      virtual FolderRoiLinkPtr linkRoi(const RoiPtr& addition, const Ice::Current& current = Ice::Current());
      virtual void addFolderRoiLinkToBoth(const FolderRoiLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
      virtual FolderRoiLinksSeq findFolderRoiLink(const RoiPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void unlinkRoi(const RoiPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void removeFolderRoiLinkFromBoth(const FolderRoiLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
       virtual FolderLinkedRoiSeq linkedRoiList(const Ice::Current& current = Ice::Current());

      //
      //  Folder.annotationLinks
      //
      virtual void unloadAnnotationLinks(const Ice::Current& current = Ice::Current());
    protected:
      virtual FolderAnnotationLinksSeq getAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual void setAnnotationLinks(const FolderAnnotationLinksSeq& _annotationLinks, const Ice::Current& current = Ice::Current());
    public:
      virtual bool isAnnotationLinksLoaded();
      virtual Ice::Int sizeOfAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual FolderAnnotationLinksSeq copyAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual FolderAnnotationLinksSeq::iterator beginAnnotationLinks();
      virtual FolderAnnotationLinksSeq::iterator endAnnotationLinks();
      virtual void addFolderAnnotationLink(const FolderAnnotationLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void addAllFolderAnnotationLinkSet(const FolderAnnotationLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void removeFolderAnnotationLink(const FolderAnnotationLinkPtr& target, const Ice::Current& current = Ice::Current());
      virtual void removeAllFolderAnnotationLinkSet(const FolderAnnotationLinksSeq& targets, const Ice::Current& current = Ice::Current());
      virtual void clearAnnotationLinks(const Ice::Current& current = Ice::Current());
      virtual void reloadAnnotationLinks(const FolderPtr& toCopy, const Ice::Current& current = Ice::Current());
      virtual omero::sys::CountMap getAnnotationLinksCountPerOwner(const Ice::Current& current = Ice::Current());
      virtual FolderAnnotationLinkPtr linkAnnotation(const AnnotationPtr& addition, const Ice::Current& current = Ice::Current());
      virtual void addFolderAnnotationLinkToBoth(const FolderAnnotationLinkPtr& link, bool /*unused*/, const Ice::Current& current = Ice::Current());
      virtual FolderAnnotationLinksSeq findFolderAnnotationLink(const AnnotationPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void unlinkAnnotation(const AnnotationPtr& removal, const Ice::Current& current = Ice::Current());
      virtual void removeFolderAnnotationLinkFromBoth(const FolderAnnotationLinkPtr& link, bool bothSides, const Ice::Current& current = Ice::Current());
       virtual FolderLinkedAnnotationSeq linkedAnnotationList(const Ice::Current& current = Ice::Current());

      //
      //  Folder.name
      //
      virtual void unloadName();
      virtual omero::RStringPtr getName(const Ice::Current& current = Ice::Current());
      virtual void setName(const omero::RStringPtr& _name, const Ice::Current& current = Ice::Current());

      //
      //  Folder.description
      //
      virtual void unloadDescription();
      virtual omero::RStringPtr getDescription(const Ice::Current& current = Ice::Current());
      virtual void setDescription(const omero::RStringPtr& _description, const Ice::Current& current = Ice::Current());
 };

}}
#endif // FOLDERI_H
